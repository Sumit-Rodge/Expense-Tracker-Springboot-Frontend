{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst common_1 = require(\"./common\");\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n//  Minimum version to try writes on secondaries.\nexports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n/**\r\n * Returns a server selector that selects for writable servers\r\n */\nfunction writableServerSelector() {\n  return function writableServer(topologyDescription, servers) {\n    return latencyWindowReducer(topologyDescription, servers.filter(s => s.isWritable));\n  };\n}\nexports.writableServerSelector = writableServerSelector;\n/**\r\n * The purpose of this selector is to select the same server, only\r\n * if it is in a state that it can have commands sent to it.\r\n */\nfunction sameServerSelector(description) {\n  return function sameServerSelector(topologyDescription, servers) {\n    if (!description) return [];\n    // Filter the servers to match the provided description only if\n    // the type is not unknown.\n    return servers.filter(sd => {\n      return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;\n    });\n  };\n}\nexports.sameServerSelector = sameServerSelector;\n/**\r\n * Returns a server selector that uses a read preference to select a\r\n * server potentially for a write on a secondary.\r\n */\nfunction secondaryWritableServerSelector(wireVersion, readPreference) {\n  // If server version < 5.0, read preference always primary.\n  // If server version >= 5.0...\n  // - If read preference is supplied, use that.\n  // - If no read preference is supplied, use primary.\n  if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {\n    return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);\n  }\n  return readPreferenceServerSelector(readPreference);\n}\nexports.secondaryWritableServerSelector = secondaryWritableServerSelector;\n/**\r\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\r\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\r\n *\r\n * @param readPreference - The read preference providing max staleness guidance\r\n * @param topologyDescription - The topology description\r\n * @param servers - The list of server descriptions to be reduced\r\n * @returns The list of servers that satisfy the requirements of max staleness\r\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`);\n  }\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);\n  }\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {\n    const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n      return result;\n    }, []);\n  }\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n    const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n    return servers.reduce((result, server) => {\n      const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n      return result;\n    }, []);\n  }\n  return servers;\n}\n/**\r\n * Determines whether a server's tags match a given set of tags\r\n *\r\n * @param tagSet - The requested tag set to match\r\n * @param serverTags - The server's tags\r\n */\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\r\n * Reduces a set of server descriptions based on tags requested by the read preference\r\n *\r\n * @param readPreference - The read preference providing the requested tags\r\n * @param servers - The list of server descriptions to reduce\r\n * @returns The list of servers matching the requested tags\r\n */\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n  return [];\n}\n/**\r\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\r\n * further specified in the \"Server Selection\" specification, found here:\r\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\r\n *\r\n * @param topologyDescription - The topology description\r\n * @param servers - The list of servers to reduce\r\n * @returns The servers which fall within an acceptable latency window\r\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n// filters\nfunction primaryFilter(server) {\n  return server.type === common_1.ServerType.RSPrimary;\n}\nfunction secondaryFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary;\n}\nfunction nearestFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;\n}\nfunction knownFilter(server) {\n  return server.type !== common_1.ServerType.Unknown;\n}\nfunction loadBalancerFilter(server) {\n  return server.type === common_1.ServerType.LoadBalancer;\n}\n/**\r\n * Returns a function which selects servers based on a provided read preference\r\n *\r\n * @param readPreference - The read preference to select with\r\n */\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');\n  }\n  return function readPreferenceServers(topologyDescription, servers, deprioritized = []) {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);\n    }\n    if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n    if (topologyDescription.type === common_1.TopologyType.Unknown) {\n      return [];\n    }\n    if (topologyDescription.type === common_1.TopologyType.Single) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n    if (topologyDescription.type === common_1.TopologyType.Sharded) {\n      const filtered = servers.filter(server => {\n        return !deprioritized.includes(server);\n      });\n      const selectable = filtered.length > 0 ? filtered : deprioritized;\n      return latencyWindowReducer(topologyDescription, selectable.filter(knownFilter));\n    }\n    const mode = readPreference.mode;\n    if (mode === read_preference_1.ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n    if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n    const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n    if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n    return selectedServers;\n  };\n}\nexports.readPreferenceServerSelector = readPreferenceServerSelector;","map":{"version":3,"names":["error_1","require","read_preference_1","common_1","IDLE_WRITE_PERIOD","SMALLEST_MAX_STALENESS_SECONDS","exports","MIN_SECONDARY_WRITE_WIRE_VERSION","writableServerSelector","writableServer","topologyDescription","servers","latencyWindowReducer","filter","s","isWritable","sameServerSelector","description","sd","address","type","ServerType","Unknown","secondaryWritableServerSelector","wireVersion","readPreference","readPreferenceServerSelector","ReadPreference","primary","maxStalenessReducer","maxStalenessSeconds","maxStaleness","maxStalenessVariance","heartbeatFrequencyMS","MongoInvalidArgumentError","TopologyType","ReplicaSetWithPrimary","Array","from","values","primaryFilter","reduce","result","server","stalenessMS","lastUpdateTime","lastWriteDate","staleness","push","ReplicaSetNoPrimary","length","sMax","max","tagSetMatch","tagSet","serverTags","keys","Object","serverTagKeys","i","key","indexOf","tagSetReducer","tags","isArray","serversMatchingTagset","matched","low","min","roundTripTime","Math","high","localThresholdMS","RSPrimary","secondaryFilter","RSSecondary","nearestFilter","knownFilter","loadBalancerFilter","LoadBalancer","isValid","readPreferenceServers","deprioritized","commonWireVersion","minWireVersion","MongoCompatibilityError","LoadBalanced","Single","Sharded","filtered","includes","selectable","mode","PRIMARY","PRIMARY_PREFERRED","NEAREST","selectedServers","SECONDARY_PREFERRED"],"sources":["C:\\Users\\sumit\\Desktop\\Final project\\Expense-Tracker-Springboot-Frontend\\node_modules\\mongodb\\src\\sdam\\server_selection.ts"],"sourcesContent":["import { MongoCompatibilityError, MongoInvalidArgumentError } from '../error';\r\nimport { ReadPreference } from '../read_preference';\r\nimport { ServerType, TopologyType } from './common';\r\nimport type { ServerDescription, TagSet } from './server_description';\r\nimport type { TopologyDescription } from './topology_description';\r\n\r\n// max staleness constants\r\nconst IDLE_WRITE_PERIOD = 10000;\r\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\r\n\r\n//  Minimum version to try writes on secondaries.\r\nexport const MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\r\n\r\n/** @internal */\r\nexport type ServerSelector = (\r\n  topologyDescription: TopologyDescription,\r\n  servers: ServerDescription[],\r\n  deprioritized?: ServerDescription[]\r\n) => ServerDescription[];\r\n\r\n/**\r\n * Returns a server selector that selects for writable servers\r\n */\r\nexport function writableServerSelector(): ServerSelector {\r\n  return function writableServer(\r\n    topologyDescription: TopologyDescription,\r\n    servers: ServerDescription[]\r\n  ): ServerDescription[] {\r\n    return latencyWindowReducer(\r\n      topologyDescription,\r\n      servers.filter((s: ServerDescription) => s.isWritable)\r\n    );\r\n  };\r\n}\r\n\r\n/**\r\n * The purpose of this selector is to select the same server, only\r\n * if it is in a state that it can have commands sent to it.\r\n */\r\nexport function sameServerSelector(description?: ServerDescription): ServerSelector {\r\n  return function sameServerSelector(\r\n    topologyDescription: TopologyDescription,\r\n    servers: ServerDescription[]\r\n  ): ServerDescription[] {\r\n    if (!description) return [];\r\n    // Filter the servers to match the provided description only if\r\n    // the type is not unknown.\r\n    return servers.filter(sd => {\r\n      return sd.address === description.address && sd.type !== ServerType.Unknown;\r\n    });\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a server selector that uses a read preference to select a\r\n * server potentially for a write on a secondary.\r\n */\r\nexport function secondaryWritableServerSelector(\r\n  wireVersion?: number,\r\n  readPreference?: ReadPreference\r\n): ServerSelector {\r\n  // If server version < 5.0, read preference always primary.\r\n  // If server version >= 5.0...\r\n  // - If read preference is supplied, use that.\r\n  // - If no read preference is supplied, use primary.\r\n  if (\r\n    !readPreference ||\r\n    !wireVersion ||\r\n    (wireVersion && wireVersion < MIN_SECONDARY_WRITE_WIRE_VERSION)\r\n  ) {\r\n    return readPreferenceServerSelector(ReadPreference.primary);\r\n  }\r\n  return readPreferenceServerSelector(readPreference);\r\n}\r\n\r\n/**\r\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\r\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\r\n *\r\n * @param readPreference - The read preference providing max staleness guidance\r\n * @param topologyDescription - The topology description\r\n * @param servers - The list of server descriptions to be reduced\r\n * @returns The list of servers that satisfy the requirements of max staleness\r\n */\r\nfunction maxStalenessReducer(\r\n  readPreference: ReadPreference,\r\n  topologyDescription: TopologyDescription,\r\n  servers: ServerDescription[]\r\n): ServerDescription[] {\r\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\r\n    return servers;\r\n  }\r\n\r\n  const maxStaleness = readPreference.maxStalenessSeconds;\r\n  const maxStalenessVariance =\r\n    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\r\n  if (maxStaleness < maxStalenessVariance) {\r\n    throw new MongoInvalidArgumentError(\r\n      `Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`\r\n    );\r\n  }\r\n\r\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\r\n    throw new MongoInvalidArgumentError(\r\n      `Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`\r\n    );\r\n  }\r\n\r\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\r\n    const primary: ServerDescription = Array.from(topologyDescription.servers.values()).filter(\r\n      primaryFilter\r\n    )[0];\r\n\r\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\r\n      const stalenessMS =\r\n        server.lastUpdateTime -\r\n        server.lastWriteDate -\r\n        (primary.lastUpdateTime - primary.lastWriteDate) +\r\n        topologyDescription.heartbeatFrequencyMS;\r\n\r\n      const staleness = stalenessMS / 1000;\r\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\r\n      if (staleness <= maxStalenessSeconds) {\r\n        result.push(server);\r\n      }\r\n\r\n      return result;\r\n    }, []);\r\n  }\r\n\r\n  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\r\n    if (servers.length === 0) {\r\n      return servers;\r\n    }\r\n\r\n    const sMax = servers.reduce((max: ServerDescription, s: ServerDescription) =>\r\n      s.lastWriteDate > max.lastWriteDate ? s : max\r\n    );\r\n\r\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\r\n      const stalenessMS =\r\n        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\r\n\r\n      const staleness = stalenessMS / 1000;\r\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\r\n      if (staleness <= maxStalenessSeconds) {\r\n        result.push(server);\r\n      }\r\n\r\n      return result;\r\n    }, []);\r\n  }\r\n\r\n  return servers;\r\n}\r\n\r\n/**\r\n * Determines whether a server's tags match a given set of tags\r\n *\r\n * @param tagSet - The requested tag set to match\r\n * @param serverTags - The server's tags\r\n */\r\nfunction tagSetMatch(tagSet: TagSet, serverTags: TagSet) {\r\n  const keys = Object.keys(tagSet);\r\n  const serverTagKeys = Object.keys(serverTags);\r\n  for (let i = 0; i < keys.length; ++i) {\r\n    const key = keys[i];\r\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Reduces a set of server descriptions based on tags requested by the read preference\r\n *\r\n * @param readPreference - The read preference providing the requested tags\r\n * @param servers - The list of server descriptions to reduce\r\n * @returns The list of servers matching the requested tags\r\n */\r\nfunction tagSetReducer(\r\n  readPreference: ReadPreference,\r\n  servers: ServerDescription[]\r\n): ServerDescription[] {\r\n  if (\r\n    readPreference.tags == null ||\r\n    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)\r\n  ) {\r\n    return servers;\r\n  }\r\n\r\n  for (let i = 0; i < readPreference.tags.length; ++i) {\r\n    const tagSet = readPreference.tags[i];\r\n    const serversMatchingTagset = servers.reduce(\r\n      (matched: ServerDescription[], server: ServerDescription) => {\r\n        if (tagSetMatch(tagSet, server.tags)) matched.push(server);\r\n        return matched;\r\n      },\r\n      []\r\n    );\r\n\r\n    if (serversMatchingTagset.length) {\r\n      return serversMatchingTagset;\r\n    }\r\n  }\r\n\r\n  return [];\r\n}\r\n\r\n/**\r\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\r\n * further specified in the \"Server Selection\" specification, found here:\r\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\r\n *\r\n * @param topologyDescription - The topology description\r\n * @param servers - The list of servers to reduce\r\n * @returns The servers which fall within an acceptable latency window\r\n */\r\nfunction latencyWindowReducer(\r\n  topologyDescription: TopologyDescription,\r\n  servers: ServerDescription[]\r\n): ServerDescription[] {\r\n  const low = servers.reduce(\r\n    (min: number, server: ServerDescription) =>\r\n      min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min),\r\n    -1\r\n  );\r\n\r\n  const high = low + topologyDescription.localThresholdMS;\r\n  return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\r\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\r\n    return result;\r\n  }, []);\r\n}\r\n\r\n// filters\r\nfunction primaryFilter(server: ServerDescription): boolean {\r\n  return server.type === ServerType.RSPrimary;\r\n}\r\n\r\nfunction secondaryFilter(server: ServerDescription): boolean {\r\n  return server.type === ServerType.RSSecondary;\r\n}\r\n\r\nfunction nearestFilter(server: ServerDescription): boolean {\r\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\r\n}\r\n\r\nfunction knownFilter(server: ServerDescription): boolean {\r\n  return server.type !== ServerType.Unknown;\r\n}\r\n\r\nfunction loadBalancerFilter(server: ServerDescription): boolean {\r\n  return server.type === ServerType.LoadBalancer;\r\n}\r\n\r\n/**\r\n * Returns a function which selects servers based on a provided read preference\r\n *\r\n * @param readPreference - The read preference to select with\r\n */\r\nexport function readPreferenceServerSelector(readPreference: ReadPreference): ServerSelector {\r\n  if (!readPreference.isValid()) {\r\n    throw new MongoInvalidArgumentError('Invalid read preference specified');\r\n  }\r\n\r\n  return function readPreferenceServers(\r\n    topologyDescription: TopologyDescription,\r\n    servers: ServerDescription[],\r\n    deprioritized: ServerDescription[] = []\r\n  ): ServerDescription[] {\r\n    const commonWireVersion = topologyDescription.commonWireVersion;\r\n    if (\r\n      commonWireVersion &&\r\n      readPreference.minWireVersion &&\r\n      readPreference.minWireVersion > commonWireVersion\r\n    ) {\r\n      throw new MongoCompatibilityError(\r\n        `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`\r\n      );\r\n    }\r\n\r\n    if (topologyDescription.type === TopologyType.LoadBalanced) {\r\n      return servers.filter(loadBalancerFilter);\r\n    }\r\n\r\n    if (topologyDescription.type === TopologyType.Unknown) {\r\n      return [];\r\n    }\r\n\r\n    if (topologyDescription.type === TopologyType.Single) {\r\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\r\n    }\r\n\r\n    if (topologyDescription.type === TopologyType.Sharded) {\r\n      const filtered = servers.filter(server => {\r\n        return !deprioritized.includes(server);\r\n      });\r\n      const selectable = filtered.length > 0 ? filtered : deprioritized;\r\n      return latencyWindowReducer(topologyDescription, selectable.filter(knownFilter));\r\n    }\r\n\r\n    const mode = readPreference.mode;\r\n    if (mode === ReadPreference.PRIMARY) {\r\n      return servers.filter(primaryFilter);\r\n    }\r\n\r\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\r\n      const result = servers.filter(primaryFilter);\r\n      if (result.length) {\r\n        return result;\r\n      }\r\n    }\r\n\r\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\r\n    const selectedServers = latencyWindowReducer(\r\n      topologyDescription,\r\n      tagSetReducer(\r\n        readPreference,\r\n        maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))\r\n      )\r\n    );\r\n\r\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\r\n      return servers.filter(primaryFilter);\r\n    }\r\n\r\n    return selectedServers;\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}