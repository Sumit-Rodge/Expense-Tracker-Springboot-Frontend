{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AutoEncrypter = exports.AutoEncryptionLoggerLevel = void 0;\nconst bson_1 = require(\"../bson\");\nconst deps_1 = require(\"../deps\");\nconst error_1 = require(\"../error\");\nconst mongo_client_1 = require(\"../mongo_client\");\nconst utils_1 = require(\"../utils\");\nconst cryptoCallbacks = require(\"./crypto_callbacks\");\nconst errors_1 = require(\"./errors\");\nconst mongocryptd_manager_1 = require(\"./mongocryptd_manager\");\nconst providers_1 = require(\"./providers\");\nconst state_machine_1 = require(\"./state_machine\");\n/** @public */\nexports.AutoEncryptionLoggerLevel = Object.freeze({\n  FatalError: 0,\n  Error: 1,\n  Warning: 2,\n  Info: 3,\n  Trace: 4\n});\n// Typescript errors if we index objects with `Symbol.for(...)`, so\n// to avoid TS errors we pull them out into variables.  Then we can type\n// the objects (and class) that we expect to see them on and prevent TS\n// errors.\n/** @internal */\nconst kDecorateResult = Symbol.for('@@mdb.decorateDecryptionResult');\n/** @internal */\nconst kDecoratedKeys = Symbol.for('@@mdb.decryptedKeys');\n/**\r\n * @internal An internal class to be used by the driver for auto encryption\r\n * **NOTE**: Not meant to be instantiated directly, this is for internal use only.\r\n */\nclass AutoEncrypter {\n  /** @internal */\n  static getMongoCrypt() {\n    const encryption = (0, deps_1.getMongoDBClientEncryption)();\n    if ('kModuleError' in encryption) {\n      throw encryption.kModuleError;\n    }\n    return encryption.MongoCrypt;\n  }\n  /**\r\n   * Create an AutoEncrypter\r\n   *\r\n   * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient\r\n   *\r\n   * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.\r\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.\r\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\r\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\r\n   *\r\n   * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>\r\n   * ```ts\r\n   * // Enabling autoEncryption via a MongoClient using mongocryptd\r\n   * const { MongoClient } = require('mongodb');\r\n   * const client = new MongoClient(URL, {\r\n   *   autoEncryption: {\r\n   *     kmsProviders: {\r\n   *       aws: {\r\n   *         accessKeyId: AWS_ACCESS_KEY,\r\n   *         secretAccessKey: AWS_SECRET_KEY\r\n   *       }\r\n   *     }\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * await client.connect();\r\n   * // From here on, the client will be encrypting / decrypting automatically\r\n   * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>\r\n   * ```ts\r\n   * // Enabling autoEncryption via a MongoClient using CSFLE shared library\r\n   * const { MongoClient } = require('mongodb');\r\n   * const client = new MongoClient(URL, {\r\n   *   autoEncryption: {\r\n   *     kmsProviders: {\r\n   *       aws: {}\r\n   *     },\r\n   *     extraOptions: {\r\n   *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',\r\n   *       cryptSharedLibRequired: true\r\n   *     }\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * await client.connect();\r\n   * // From here on, the client will be encrypting / decrypting automatically\r\n   */\n  constructor(client, options) {\n    /**\r\n     * Used by devtools to enable decorating decryption results.\r\n     *\r\n     * When set and enabled, `decrypt` will automatically recursively\r\n     * traverse a decrypted document and if a field has been decrypted,\r\n     * it will mark it as decrypted.  Compass uses this to determine which\r\n     * fields were decrypted.\r\n     */\n    this[_a] = false;\n    this._client = client;\n    this._bypassEncryption = options.bypassAutoEncryption === true;\n    this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';\n    this._keyVaultClient = options.keyVaultClient || client;\n    this._metaDataClient = options.metadataClient || client;\n    this._proxyOptions = options.proxyOptions || {};\n    this._tlsOptions = options.tlsOptions || {};\n    this._kmsProviders = options.kmsProviders || {};\n    const mongoCryptOptions = {\n      cryptoCallbacks\n    };\n    if (options.schemaMap) {\n      mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap) ? options.schemaMap : (0, bson_1.serialize)(options.schemaMap);\n    }\n    if (options.encryptedFieldsMap) {\n      mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap) ? options.encryptedFieldsMap : (0, bson_1.serialize)(options.encryptedFieldsMap);\n    }\n    mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders;\n    if (options.options?.logger) {\n      mongoCryptOptions.logger = options.options.logger;\n    }\n    if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {\n      mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;\n    }\n    if (options.bypassQueryAnalysis) {\n      mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;\n    }\n    this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;\n    if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {\n      // Only for driver testing\n      mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;\n    } else if (!this._bypassMongocryptdAndCryptShared) {\n      mongoCryptOptions.cryptSharedLibSearchPaths = ['$SYSTEM'];\n    }\n    const MongoCrypt = AutoEncrypter.getMongoCrypt();\n    this._mongocrypt = new MongoCrypt(mongoCryptOptions);\n    this._contextCounter = 0;\n    if (options.extraOptions && options.extraOptions.cryptSharedLibRequired && !this.cryptSharedLibVersionInfo) {\n      throw new errors_1.MongoCryptInvalidArgumentError('`cryptSharedLibRequired` set but no crypt_shared library loaded');\n    }\n    // Only instantiate mongocryptd manager/client once we know for sure\n    // that we are not using the CSFLE shared library.\n    if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {\n      this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);\n      const clientOptions = {\n        serverSelectionTimeoutMS: 10000\n      };\n      if (options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== 'string') {\n        clientOptions.family = 4;\n      }\n      this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);\n    }\n  }\n  /**\r\n   * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.\r\n   *\r\n   * This function is a no-op when bypassSpawn is set or the crypt shared library is used.\r\n   */\n  async init() {\n    if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {\n      return;\n    }\n    if (!this._mongocryptdManager) {\n      throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.');\n    }\n    if (!this._mongocryptdClient) {\n      throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.');\n    }\n    if (!this._mongocryptdManager.bypassSpawn) {\n      await this._mongocryptdManager.spawn();\n    }\n    try {\n      const client = await this._mongocryptdClient.connect();\n      return client;\n    } catch (error) {\n      const {\n        message\n      } = error;\n      if (message && (message.match(/timed out after/) || message.match(/ENOTFOUND/))) {\n        throw new error_1.MongoRuntimeError('Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn', {\n          cause: error\n        });\n      }\n      throw error;\n    }\n  }\n  /**\r\n   * Cleans up the `_mongocryptdClient`, if present.\r\n   */\n  async teardown(force) {\n    await this._mongocryptdClient?.close(force);\n  }\n  /**\r\n   * Encrypt a command for a given namespace.\r\n   */\n  async encrypt(ns, cmd, options = {}) {\n    if (this._bypassEncryption) {\n      // If `bypassAutoEncryption` has been specified, don't encrypt\n      return cmd;\n    }\n    const commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options);\n    const context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);\n    context.id = this._contextCounter++;\n    context.ns = ns;\n    context.document = cmd;\n    const stateMachine = new state_machine_1.StateMachine({\n      promoteValues: false,\n      promoteLongs: false,\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    return stateMachine.execute(this, context);\n  }\n  /**\r\n   * Decrypt a command response\r\n   */\n  async decrypt(response, options = {}) {\n    const buffer = Buffer.isBuffer(response) ? response : (0, bson_1.serialize)(response, options);\n    const context = this._mongocrypt.makeDecryptionContext(buffer);\n    context.id = this._contextCounter++;\n    const stateMachine = new state_machine_1.StateMachine({\n      ...options,\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const decorateResult = this[kDecorateResult];\n    const result = await stateMachine.execute(this, context);\n    if (decorateResult) {\n      decorateDecryptionResult(result, response);\n    }\n    return result;\n  }\n  /**\r\n   * Ask the user for KMS credentials.\r\n   *\r\n   * This returns anything that looks like the kmsProviders original input\r\n   * option. It can be empty, and any provider specified here will override\r\n   * the original ones.\r\n   */\n  async askForKMSCredentials() {\n    return (0, providers_1.refreshKMSCredentials)(this._kmsProviders);\n  }\n  /**\r\n   * Return the current libmongocrypt's CSFLE shared library version\r\n   * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE\r\n   * shared library was loaded.\r\n   */\n  get cryptSharedLibVersionInfo() {\n    return this._mongocrypt.cryptSharedLibVersionInfo;\n  }\n  static get libmongocryptVersion() {\n    return AutoEncrypter.getMongoCrypt().libmongocryptVersion;\n  }\n}\nexports.AutoEncrypter = AutoEncrypter;\n_a = kDecorateResult;\n/**\r\n * Recurse through the (identically-shaped) `decrypted` and `original`\r\n * objects and attach a `decryptedKeys` property on each sub-object that\r\n * contained encrypted fields. Because we only call this on BSON responses,\r\n * we do not need to worry about circular references.\r\n *\r\n * @internal\r\n */\nfunction decorateDecryptionResult(decrypted, original, isTopLevelDecorateCall = true) {\n  if (isTopLevelDecorateCall) {\n    // The original value could have been either a JS object or a BSON buffer\n    if (Buffer.isBuffer(original)) {\n      original = (0, bson_1.deserialize)(original);\n    }\n    if (Buffer.isBuffer(decrypted)) {\n      throw new error_1.MongoRuntimeError('Expected result of decryption to be deserialized BSON object');\n    }\n  }\n  if (!decrypted || typeof decrypted !== 'object') return;\n  for (const k of Object.keys(decrypted)) {\n    const originalValue = original[k];\n    // An object was decrypted by libmongocrypt if and only if it was\n    // a BSON Binary object with subtype 6.\n    if (originalValue && originalValue._bsontype === 'Binary' && originalValue.sub_type === 6) {\n      if (!decrypted[kDecoratedKeys]) {\n        Object.defineProperty(decrypted, kDecoratedKeys, {\n          value: [],\n          configurable: true,\n          enumerable: false,\n          writable: false\n        });\n      }\n      // this is defined in the preceding if-statement\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      decrypted[kDecoratedKeys].push(k);\n      // Do not recurse into this decrypted value. It could be a sub-document/array,\n      // in which case there is no original value associated with its subfields.\n      continue;\n    }\n    decorateDecryptionResult(decrypted[k], originalValue, false);\n  }\n}","map":{"version":3,"names":["bson_1","require","deps_1","error_1","mongo_client_1","utils_1","cryptoCallbacks","errors_1","mongocryptd_manager_1","providers_1","state_machine_1","exports","AutoEncryptionLoggerLevel","Object","freeze","FatalError","Error","Warning","Info","Trace","kDecorateResult","Symbol","for","kDecoratedKeys","AutoEncrypter","getMongoCrypt","encryption","getMongoDBClientEncryption","kModuleError","MongoCrypt","constructor","client","options","_a","_client","_bypassEncryption","bypassAutoEncryption","_keyVaultNamespace","keyVaultNamespace","_keyVaultClient","keyVaultClient","_metaDataClient","metadataClient","_proxyOptions","proxyOptions","_tlsOptions","tlsOptions","_kmsProviders","kmsProviders","mongoCryptOptions","schemaMap","Buffer","isBuffer","serialize","encryptedFieldsMap","logger","extraOptions","cryptSharedLibPath","bypassQueryAnalysis","_bypassMongocryptdAndCryptShared","cryptSharedLibSearchPaths","_mongocrypt","_contextCounter","cryptSharedLibRequired","cryptSharedLibVersionInfo","MongoCryptInvalidArgumentError","_mongocryptdManager","MongocryptdManager","clientOptions","serverSelectionTimeoutMS","mongocryptdURI","family","_mongocryptdClient","MongoClient","uri","init","MongoRuntimeError","bypassSpawn","spawn","connect","error","message","match","cause","teardown","force","close","encrypt","ns","cmd","commandBuffer","context","makeEncryptionContext","MongoDBCollectionNamespace","fromString","db","id","document","stateMachine","StateMachine","promoteValues","promoteLongs","execute","decrypt","response","buffer","makeDecryptionContext","decorateResult","result","decorateDecryptionResult","askForKMSCredentials","refreshKMSCredentials","libmongocryptVersion","decrypted","original","isTopLevelDecorateCall","deserialize","k","keys","originalValue","_bsontype","sub_type","defineProperty","value","configurable","enumerable","writable","push"],"sources":["C:\\Users\\sumit\\Desktop\\Final project\\Expense-Tracker-Springboot-Frontend\\node_modules\\mongodb\\src\\client-side-encryption\\auto_encrypter.ts"],"sourcesContent":["import {\r\n  type MongoCrypt,\r\n  type MongoCryptConstructor,\r\n  type MongoCryptOptions\r\n} from 'mongodb-client-encryption';\r\n\r\nimport { deserialize, type Document, serialize } from '../bson';\r\nimport { type CommandOptions, type ProxyOptions } from '../cmap/connection';\r\nimport { getMongoDBClientEncryption } from '../deps';\r\nimport { MongoRuntimeError } from '../error';\r\nimport { MongoClient, type MongoClientOptions } from '../mongo_client';\r\nimport { MongoDBCollectionNamespace } from '../utils';\r\nimport * as cryptoCallbacks from './crypto_callbacks';\r\nimport { MongoCryptInvalidArgumentError } from './errors';\r\nimport { MongocryptdManager } from './mongocryptd_manager';\r\nimport { type KMSProviders, refreshKMSCredentials } from './providers';\r\nimport { type CSFLEKMSTlsOptions, StateMachine } from './state_machine';\r\n\r\n/** @public */\r\nexport interface AutoEncryptionOptions {\r\n  /** @internal client for metadata lookups */\r\n  metadataClient?: MongoClient;\r\n  /** A `MongoClient` used to fetch keys from a key vault */\r\n  keyVaultClient?: MongoClient;\r\n  /** The namespace where keys are stored in the key vault */\r\n  keyVaultNamespace?: string;\r\n  /** Configuration options that are used by specific KMS providers during key generation, encryption, and decryption. */\r\n  kmsProviders?: {\r\n    /** Configuration options for using 'aws' as your KMS provider */\r\n    aws?:\r\n      | {\r\n          /** The access key used for the AWS KMS provider */\r\n          accessKeyId: string;\r\n          /** The secret access key used for the AWS KMS provider */\r\n          secretAccessKey: string;\r\n          /**\r\n           * An optional AWS session token that will be used as the\r\n           * X-Amz-Security-Token header for AWS requests.\r\n           */\r\n          sessionToken?: string;\r\n        }\r\n      | Record<string, never>;\r\n    /** Configuration options for using 'local' as your KMS provider */\r\n    local?: {\r\n      /**\r\n       * The master key used to encrypt/decrypt data keys.\r\n       * A 96-byte long Buffer or base64 encoded string.\r\n       */\r\n      key: Buffer | string;\r\n    };\r\n    /** Configuration options for using 'azure' as your KMS provider */\r\n    azure?:\r\n      | {\r\n          /** The tenant ID identifies the organization for the account */\r\n          tenantId: string;\r\n          /** The client ID to authenticate a registered application */\r\n          clientId: string;\r\n          /** The client secret to authenticate a registered application */\r\n          clientSecret: string;\r\n          /**\r\n           * If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\r\n           * This is optional, and only needed if customer is using a non-commercial Azure instance\r\n           * (e.g. a government or China account, which use different URLs).\r\n           * Defaults to \"login.microsoftonline.com\"\r\n           */\r\n          identityPlatformEndpoint?: string | undefined;\r\n        }\r\n      | {\r\n          /**\r\n           * If present, an access token to authenticate with Azure.\r\n           */\r\n          accessToken: string;\r\n        }\r\n      | Record<string, never>;\r\n    /** Configuration options for using 'gcp' as your KMS provider */\r\n    gcp?:\r\n      | {\r\n          /** The service account email to authenticate */\r\n          email: string;\r\n          /** A PKCS#8 encrypted key. This can either be a base64 string or a binary representation */\r\n          privateKey: string | Buffer;\r\n          /**\r\n           * If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\r\n           * Defaults to \"oauth2.googleapis.com\"\r\n           */\r\n          endpoint?: string | undefined;\r\n        }\r\n      | {\r\n          /**\r\n           * If present, an access token to authenticate with GCP.\r\n           */\r\n          accessToken: string;\r\n        }\r\n      | Record<string, never>;\r\n    /**\r\n     * Configuration options for using 'kmip' as your KMS provider\r\n     */\r\n    kmip?: {\r\n      /**\r\n       * The output endpoint string.\r\n       * The endpoint consists of a hostname and port separated by a colon.\r\n       * E.g. \"example.com:123\". A port is always present.\r\n       */\r\n      endpoint?: string;\r\n    };\r\n  };\r\n  /**\r\n   * A map of namespaces to a local JSON schema for encryption\r\n   *\r\n   * **NOTE**: Supplying options.schemaMap provides more security than relying on JSON Schemas obtained from the server.\r\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending decrypted data that should be encrypted.\r\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\r\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\r\n   */\r\n  schemaMap?: Document;\r\n  /** Supply a schema for the encrypted fields in the document  */\r\n  encryptedFieldsMap?: Document;\r\n  /** Allows the user to bypass auto encryption, maintaining implicit decryption */\r\n  bypassAutoEncryption?: boolean;\r\n  /** Allows users to bypass query analysis */\r\n  bypassQueryAnalysis?: boolean;\r\n  options?: {\r\n    /** An optional hook to catch logging messages from the underlying encryption engine */\r\n    logger?: (level: AutoEncryptionLoggerLevel, message: string) => void;\r\n  };\r\n  extraOptions?: {\r\n    /**\r\n     * A local process the driver communicates with to determine how to encrypt values in a command.\r\n     * Defaults to \"mongodb://%2Fvar%2Fmongocryptd.sock\" if domain sockets are available or \"mongodb://localhost:27020\" otherwise\r\n     */\r\n    mongocryptdURI?: string;\r\n    /** If true, autoEncryption will not attempt to spawn a mongocryptd before connecting  */\r\n    mongocryptdBypassSpawn?: boolean;\r\n    /** The path to the mongocryptd executable on the system */\r\n    mongocryptdSpawnPath?: string;\r\n    /** Command line arguments to use when auto-spawning a mongocryptd */\r\n    mongocryptdSpawnArgs?: string[];\r\n    /**\r\n     * Full path to a MongoDB Crypt shared library to be used (instead of mongocryptd).\r\n     *\r\n     * This needs to be the path to the file itself, not a directory.\r\n     * It can be an absolute or relative path. If the path is relative and\r\n     * its first component is `$ORIGIN`, it will be replaced by the directory\r\n     * containing the mongodb-client-encryption native addon file. Otherwise,\r\n     * the path will be interpreted relative to the current working directory.\r\n     *\r\n     * Currently, loading different MongoDB Crypt shared library files from different\r\n     * MongoClients in the same process is not supported.\r\n     *\r\n     * If this option is provided and no MongoDB Crypt shared library could be loaded\r\n     * from the specified location, creating the MongoClient will fail.\r\n     *\r\n     * If this option is not provided and `cryptSharedLibRequired` is not specified,\r\n     * the AutoEncrypter will attempt to spawn and/or use mongocryptd according\r\n     * to the mongocryptd-specific `extraOptions` options.\r\n     *\r\n     * Specifying a path prevents mongocryptd from being used as a fallback.\r\n     *\r\n     * Requires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.\r\n     */\r\n    cryptSharedLibPath?: string;\r\n    /**\r\n     * If specified, never use mongocryptd and instead fail when the MongoDB Crypt\r\n     * shared library could not be loaded.\r\n     *\r\n     * This is always true when `cryptSharedLibPath` is specified.\r\n     *\r\n     * Requires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.\r\n     */\r\n    cryptSharedLibRequired?: boolean;\r\n    /**\r\n     * Search paths for a MongoDB Crypt shared library to be used (instead of mongocryptd)\r\n     * Only for driver testing!\r\n     * @internal\r\n     */\r\n    cryptSharedLibSearchPaths?: string[];\r\n  };\r\n  proxyOptions?: ProxyOptions;\r\n  /** The TLS options to use connecting to the KMS provider */\r\n  tlsOptions?: CSFLEKMSTlsOptions;\r\n}\r\n\r\n/**\r\n * @public\r\n *\r\n * Extra options related to the mongocryptd process\r\n * \\* _Available in MongoDB 6.0 or higher._\r\n */\r\nexport type AutoEncryptionExtraOptions = NonNullable<AutoEncryptionOptions['extraOptions']>;\r\n\r\n/** @public */\r\nexport const AutoEncryptionLoggerLevel = Object.freeze({\r\n  FatalError: 0,\r\n  Error: 1,\r\n  Warning: 2,\r\n  Info: 3,\r\n  Trace: 4\r\n} as const);\r\n\r\n/**\r\n * @public\r\n * The level of severity of the log message\r\n *\r\n * | Value | Level |\r\n * |-------|-------|\r\n * | 0 | Fatal Error |\r\n * | 1 | Error |\r\n * | 2 | Warning |\r\n * | 3 | Info |\r\n * | 4 | Trace |\r\n */\r\nexport type AutoEncryptionLoggerLevel =\r\n  (typeof AutoEncryptionLoggerLevel)[keyof typeof AutoEncryptionLoggerLevel];\r\n\r\n// Typescript errors if we index objects with `Symbol.for(...)`, so\r\n// to avoid TS errors we pull them out into variables.  Then we can type\r\n// the objects (and class) that we expect to see them on and prevent TS\r\n// errors.\r\n/** @internal */\r\nconst kDecorateResult = Symbol.for('@@mdb.decorateDecryptionResult');\r\n/** @internal */\r\nconst kDecoratedKeys = Symbol.for('@@mdb.decryptedKeys');\r\n\r\n/**\r\n * @internal An internal class to be used by the driver for auto encryption\r\n * **NOTE**: Not meant to be instantiated directly, this is for internal use only.\r\n */\r\nexport class AutoEncrypter {\r\n  _client: MongoClient;\r\n  _bypassEncryption: boolean;\r\n  _keyVaultNamespace: string;\r\n  _keyVaultClient: MongoClient;\r\n  _metaDataClient: MongoClient;\r\n  _proxyOptions: ProxyOptions;\r\n  _tlsOptions: CSFLEKMSTlsOptions;\r\n  _kmsProviders: KMSProviders;\r\n  _bypassMongocryptdAndCryptShared: boolean;\r\n  _contextCounter: number;\r\n\r\n  _mongocryptdManager?: MongocryptdManager;\r\n  _mongocryptdClient?: MongoClient;\r\n\r\n  /** @internal */\r\n  _mongocrypt: MongoCrypt;\r\n\r\n  /**\r\n   * Used by devtools to enable decorating decryption results.\r\n   *\r\n   * When set and enabled, `decrypt` will automatically recursively\r\n   * traverse a decrypted document and if a field has been decrypted,\r\n   * it will mark it as decrypted.  Compass uses this to determine which\r\n   * fields were decrypted.\r\n   */\r\n  [kDecorateResult] = false;\r\n\r\n  /** @internal */\r\n  static getMongoCrypt(): MongoCryptConstructor {\r\n    const encryption = getMongoDBClientEncryption();\r\n    if ('kModuleError' in encryption) {\r\n      throw encryption.kModuleError;\r\n    }\r\n    return encryption.MongoCrypt;\r\n  }\r\n\r\n  /**\r\n   * Create an AutoEncrypter\r\n   *\r\n   * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient\r\n   *\r\n   * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.\r\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.\r\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\r\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\r\n   *\r\n   * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>\r\n   * ```ts\r\n   * // Enabling autoEncryption via a MongoClient using mongocryptd\r\n   * const { MongoClient } = require('mongodb');\r\n   * const client = new MongoClient(URL, {\r\n   *   autoEncryption: {\r\n   *     kmsProviders: {\r\n   *       aws: {\r\n   *         accessKeyId: AWS_ACCESS_KEY,\r\n   *         secretAccessKey: AWS_SECRET_KEY\r\n   *       }\r\n   *     }\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * await client.connect();\r\n   * // From here on, the client will be encrypting / decrypting automatically\r\n   * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>\r\n   * ```ts\r\n   * // Enabling autoEncryption via a MongoClient using CSFLE shared library\r\n   * const { MongoClient } = require('mongodb');\r\n   * const client = new MongoClient(URL, {\r\n   *   autoEncryption: {\r\n   *     kmsProviders: {\r\n   *       aws: {}\r\n   *     },\r\n   *     extraOptions: {\r\n   *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',\r\n   *       cryptSharedLibRequired: true\r\n   *     }\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * await client.connect();\r\n   * // From here on, the client will be encrypting / decrypting automatically\r\n   */\r\n  constructor(client: MongoClient, options: AutoEncryptionOptions) {\r\n    this._client = client;\r\n    this._bypassEncryption = options.bypassAutoEncryption === true;\r\n\r\n    this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';\r\n    this._keyVaultClient = options.keyVaultClient || client;\r\n    this._metaDataClient = options.metadataClient || client;\r\n    this._proxyOptions = options.proxyOptions || {};\r\n    this._tlsOptions = options.tlsOptions || {};\r\n    this._kmsProviders = options.kmsProviders || {};\r\n\r\n    const mongoCryptOptions: MongoCryptOptions = {\r\n      cryptoCallbacks\r\n    };\r\n    if (options.schemaMap) {\r\n      mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap)\r\n        ? options.schemaMap\r\n        : (serialize(options.schemaMap) as Buffer);\r\n    }\r\n\r\n    if (options.encryptedFieldsMap) {\r\n      mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap)\r\n        ? options.encryptedFieldsMap\r\n        : (serialize(options.encryptedFieldsMap) as Buffer);\r\n    }\r\n\r\n    mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders)\r\n      ? (serialize(this._kmsProviders) as Buffer)\r\n      : this._kmsProviders;\r\n\r\n    if (options.options?.logger) {\r\n      mongoCryptOptions.logger = options.options.logger;\r\n    }\r\n\r\n    if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {\r\n      mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;\r\n    }\r\n\r\n    if (options.bypassQueryAnalysis) {\r\n      mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;\r\n    }\r\n\r\n    this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;\r\n\r\n    if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {\r\n      // Only for driver testing\r\n      mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;\r\n    } else if (!this._bypassMongocryptdAndCryptShared) {\r\n      mongoCryptOptions.cryptSharedLibSearchPaths = ['$SYSTEM'];\r\n    }\r\n\r\n    const MongoCrypt = AutoEncrypter.getMongoCrypt();\r\n    this._mongocrypt = new MongoCrypt(mongoCryptOptions);\r\n    this._contextCounter = 0;\r\n\r\n    if (\r\n      options.extraOptions &&\r\n      options.extraOptions.cryptSharedLibRequired &&\r\n      !this.cryptSharedLibVersionInfo\r\n    ) {\r\n      throw new MongoCryptInvalidArgumentError(\r\n        '`cryptSharedLibRequired` set but no crypt_shared library loaded'\r\n      );\r\n    }\r\n\r\n    // Only instantiate mongocryptd manager/client once we know for sure\r\n    // that we are not using the CSFLE shared library.\r\n    if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {\r\n      this._mongocryptdManager = new MongocryptdManager(options.extraOptions);\r\n      const clientOptions: MongoClientOptions = {\r\n        serverSelectionTimeoutMS: 10000\r\n      };\r\n\r\n      if (options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== 'string') {\r\n        clientOptions.family = 4;\r\n      }\r\n\r\n      this._mongocryptdClient = new MongoClient(this._mongocryptdManager.uri, clientOptions);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.\r\n   *\r\n   * This function is a no-op when bypassSpawn is set or the crypt shared library is used.\r\n   */\r\n  async init(): Promise<MongoClient | void> {\r\n    if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {\r\n      return;\r\n    }\r\n    if (!this._mongocryptdManager) {\r\n      throw new MongoRuntimeError(\r\n        'Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.'\r\n      );\r\n    }\r\n    if (!this._mongocryptdClient) {\r\n      throw new MongoRuntimeError(\r\n        'Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.'\r\n      );\r\n    }\r\n\r\n    if (!this._mongocryptdManager.bypassSpawn) {\r\n      await this._mongocryptdManager.spawn();\r\n    }\r\n\r\n    try {\r\n      const client = await this._mongocryptdClient.connect();\r\n      return client;\r\n    } catch (error) {\r\n      const { message } = error;\r\n      if (message && (message.match(/timed out after/) || message.match(/ENOTFOUND/))) {\r\n        throw new MongoRuntimeError(\r\n          'Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn',\r\n          { cause: error }\r\n        );\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleans up the `_mongocryptdClient`, if present.\r\n   */\r\n  async teardown(force: boolean): Promise<void> {\r\n    await this._mongocryptdClient?.close(force);\r\n  }\r\n\r\n  /**\r\n   * Encrypt a command for a given namespace.\r\n   */\r\n  async encrypt(\r\n    ns: string,\r\n    cmd: Document,\r\n    options: CommandOptions = {}\r\n  ): Promise<Document | Uint8Array> {\r\n    if (this._bypassEncryption) {\r\n      // If `bypassAutoEncryption` has been specified, don't encrypt\r\n      return cmd;\r\n    }\r\n\r\n    const commandBuffer = Buffer.isBuffer(cmd) ? cmd : serialize(cmd, options);\r\n\r\n    const context = this._mongocrypt.makeEncryptionContext(\r\n      MongoDBCollectionNamespace.fromString(ns).db,\r\n      commandBuffer\r\n    );\r\n\r\n    context.id = this._contextCounter++;\r\n    context.ns = ns;\r\n    context.document = cmd;\r\n\r\n    const stateMachine = new StateMachine({\r\n      promoteValues: false,\r\n      promoteLongs: false,\r\n      proxyOptions: this._proxyOptions,\r\n      tlsOptions: this._tlsOptions\r\n    });\r\n    return stateMachine.execute<Document>(this, context);\r\n  }\r\n\r\n  /**\r\n   * Decrypt a command response\r\n   */\r\n  async decrypt(response: Uint8Array | Document, options: CommandOptions = {}): Promise<Document> {\r\n    const buffer = Buffer.isBuffer(response) ? response : serialize(response, options);\r\n\r\n    const context = this._mongocrypt.makeDecryptionContext(buffer);\r\n\r\n    context.id = this._contextCounter++;\r\n\r\n    const stateMachine = new StateMachine({\r\n      ...options,\r\n      proxyOptions: this._proxyOptions,\r\n      tlsOptions: this._tlsOptions\r\n    });\r\n\r\n    const decorateResult = this[kDecorateResult];\r\n    const result = await stateMachine.execute<Document>(this, context);\r\n    if (decorateResult) {\r\n      decorateDecryptionResult(result, response);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Ask the user for KMS credentials.\r\n   *\r\n   * This returns anything that looks like the kmsProviders original input\r\n   * option. It can be empty, and any provider specified here will override\r\n   * the original ones.\r\n   */\r\n  async askForKMSCredentials(): Promise<KMSProviders> {\r\n    return refreshKMSCredentials(this._kmsProviders);\r\n  }\r\n\r\n  /**\r\n   * Return the current libmongocrypt's CSFLE shared library version\r\n   * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE\r\n   * shared library was loaded.\r\n   */\r\n  get cryptSharedLibVersionInfo(): { version: bigint; versionStr: string } | null {\r\n    return this._mongocrypt.cryptSharedLibVersionInfo;\r\n  }\r\n\r\n  static get libmongocryptVersion(): string {\r\n    return AutoEncrypter.getMongoCrypt().libmongocryptVersion;\r\n  }\r\n}\r\n\r\n/**\r\n * Recurse through the (identically-shaped) `decrypted` and `original`\r\n * objects and attach a `decryptedKeys` property on each sub-object that\r\n * contained encrypted fields. Because we only call this on BSON responses,\r\n * we do not need to worry about circular references.\r\n *\r\n * @internal\r\n */\r\nfunction decorateDecryptionResult(\r\n  decrypted: Document & { [kDecoratedKeys]?: Array<string> },\r\n  original: Document,\r\n  isTopLevelDecorateCall = true\r\n): void {\r\n  if (isTopLevelDecorateCall) {\r\n    // The original value could have been either a JS object or a BSON buffer\r\n    if (Buffer.isBuffer(original)) {\r\n      original = deserialize(original);\r\n    }\r\n    if (Buffer.isBuffer(decrypted)) {\r\n      throw new MongoRuntimeError('Expected result of decryption to be deserialized BSON object');\r\n    }\r\n  }\r\n\r\n  if (!decrypted || typeof decrypted !== 'object') return;\r\n  for (const k of Object.keys(decrypted)) {\r\n    const originalValue = original[k];\r\n\r\n    // An object was decrypted by libmongocrypt if and only if it was\r\n    // a BSON Binary object with subtype 6.\r\n    if (originalValue && originalValue._bsontype === 'Binary' && originalValue.sub_type === 6) {\r\n      if (!decrypted[kDecoratedKeys]) {\r\n        Object.defineProperty(decrypted, kDecoratedKeys, {\r\n          value: [],\r\n          configurable: true,\r\n          enumerable: false,\r\n          writable: false\r\n        });\r\n      }\r\n      // this is defined in the preceding if-statement\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      decrypted[kDecoratedKeys]!.push(k);\r\n      // Do not recurse into this decrypted value. It could be a sub-document/array,\r\n      // in which case there is no original value associated with its subfields.\r\n      continue;\r\n    }\r\n\r\n    decorateDecryptionResult(decrypted[k], originalValue, false);\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}