{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadAzureCredentials = exports.fetchAzureKMSToken = exports.prepareRequest = exports.tokenCache = exports.AzureCredentialCache = void 0;\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"./utils\");\nconst MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;\n/**\r\n * @internal\r\n */\nclass AzureCredentialCache {\n  constructor() {\n    this.cachedToken = null;\n  }\n  async getToken() {\n    if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {\n      this.cachedToken = await this._getToken();\n    }\n    return {\n      accessToken: this.cachedToken.accessToken\n    };\n  }\n  needsRefresh(token) {\n    const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();\n    return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;\n  }\n  /**\r\n   * exposed for testing\r\n   */\n  resetCache() {\n    this.cachedToken = null;\n  }\n  /**\r\n   * exposed for testing\r\n   */\n  _getToken() {\n    return fetchAzureKMSToken();\n  }\n}\nexports.AzureCredentialCache = AzureCredentialCache;\n/** @internal */\nexports.tokenCache = new AzureCredentialCache();\n/** @internal */\nasync function parseResponse(response) {\n  const {\n    status,\n    body: rawBody\n  } = response;\n  const body = (() => {\n    try {\n      return JSON.parse(rawBody);\n    } catch {\n      throw new errors_1.MongoCryptAzureKMSRequestError('Malformed JSON body in GET request.');\n    }\n  })();\n  if (status !== 200) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Unable to complete request.', body);\n  }\n  if (!body.access_token) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - missing field `access_token`.');\n  }\n  if (!body.expires_in) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - missing field `expires_in`.');\n  }\n  const expiresInMS = Number(body.expires_in) * 1000;\n  if (Number.isNaN(expiresInMS)) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - unable to parse int from `expires_in` field.');\n  }\n  return {\n    accessToken: body.access_token,\n    expiresOnTimestamp: Date.now() + expiresInMS\n  };\n}\n/**\r\n * @internal\r\n *\r\n * parses any options provided by prose tests to `fetchAzureKMSToken` and merges them with\r\n * the default values for headers and the request url.\r\n */\nfunction prepareRequest(options) {\n  const url = new URL(options.url?.toString() ?? 'http://169.254.169.254/metadata/identity/oauth2/token');\n  url.searchParams.append('api-version', '2018-02-01');\n  url.searchParams.append('resource', 'https://vault.azure.net');\n  const headers = {\n    ...options.headers,\n    'Content-Type': 'application/json',\n    Metadata: true\n  };\n  return {\n    headers,\n    url\n  };\n}\nexports.prepareRequest = prepareRequest;\n/**\r\n * @internal\r\n *\r\n * `AzureKMSRequestOptions` allows prose tests to modify the http request sent to the idms\r\n * servers.  This is required to simulate different server conditions.  No options are expected to\r\n * be set outside of tests.\r\n *\r\n * exposed for CSFLE\r\n * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)\r\n */\nasync function fetchAzureKMSToken(options = {}) {\n  const {\n    headers,\n    url\n  } = prepareRequest(options);\n  const response = await (0, utils_1.get)(url, {\n    headers\n  }).catch(error => {\n    if (error instanceof errors_1.MongoCryptKMSRequestNetworkTimeoutError) {\n      throw new errors_1.MongoCryptAzureKMSRequestError(`[Azure KMS] ${error.message}`);\n    }\n    throw error;\n  });\n  return parseResponse(response);\n}\nexports.fetchAzureKMSToken = fetchAzureKMSToken;\n/**\r\n * @internal\r\n *\r\n * @throws Will reject with a `MongoCryptError` if the http request fails or the http response is malformed.\r\n */\nasync function loadAzureCredentials(kmsProviders) {\n  const azure = await exports.tokenCache.getToken();\n  return {\n    ...kmsProviders,\n    azure\n  };\n}\nexports.loadAzureCredentials = loadAzureCredentials;","map":{"version":3,"names":["errors_1","require","utils_1","MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS","AzureCredentialCache","constructor","cachedToken","getToken","needsRefresh","_getToken","accessToken","token","timeUntilExpirationMS","expiresOnTimestamp","Date","now","resetCache","fetchAzureKMSToken","exports","tokenCache","parseResponse","response","status","body","rawBody","JSON","parse","MongoCryptAzureKMSRequestError","access_token","expires_in","expiresInMS","Number","isNaN","prepareRequest","options","url","URL","toString","searchParams","append","headers","Metadata","get","catch","error","MongoCryptKMSRequestNetworkTimeoutError","message","loadAzureCredentials","kmsProviders","azure"],"sources":["C:\\Users\\sumit\\Desktop\\Final project\\Expense-Tracker-Springboot-Frontend\\node_modules\\mongodb\\src\\client-side-encryption\\providers\\azure.ts"],"sourcesContent":["import { type Document } from '../../bson';\r\nimport { MongoCryptAzureKMSRequestError, MongoCryptKMSRequestNetworkTimeoutError } from '../errors';\r\nimport { type KMSProviders } from './index';\r\nimport { get } from './utils';\r\n\r\nconst MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;\r\n\r\n/**\r\n * The access token that libmongocrypt expects for Azure kms.\r\n */\r\ninterface AccessToken {\r\n  accessToken: string;\r\n}\r\n\r\n/**\r\n * The response from the azure idms endpoint, including the `expiresOnTimestamp`.\r\n * `expiresOnTimestamp` is needed for caching.\r\n */\r\ninterface AzureTokenCacheEntry extends AccessToken {\r\n  accessToken: string;\r\n  expiresOnTimestamp: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class AzureCredentialCache {\r\n  cachedToken: AzureTokenCacheEntry | null = null;\r\n\r\n  async getToken(): Promise<AccessToken> {\r\n    if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {\r\n      this.cachedToken = await this._getToken();\r\n    }\r\n\r\n    return { accessToken: this.cachedToken.accessToken };\r\n  }\r\n\r\n  needsRefresh(token: AzureTokenCacheEntry): boolean {\r\n    const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();\r\n    return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;\r\n  }\r\n\r\n  /**\r\n   * exposed for testing\r\n   */\r\n  resetCache() {\r\n    this.cachedToken = null;\r\n  }\r\n\r\n  /**\r\n   * exposed for testing\r\n   */\r\n  _getToken(): Promise<AzureTokenCacheEntry> {\r\n    return fetchAzureKMSToken();\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport const tokenCache = new AzureCredentialCache();\r\n\r\n/** @internal */\r\nasync function parseResponse(response: {\r\n  body: string;\r\n  status?: number;\r\n}): Promise<AzureTokenCacheEntry> {\r\n  const { status, body: rawBody } = response;\r\n\r\n  const body: { expires_in?: number; access_token?: string } = (() => {\r\n    try {\r\n      return JSON.parse(rawBody);\r\n    } catch {\r\n      throw new MongoCryptAzureKMSRequestError('Malformed JSON body in GET request.');\r\n    }\r\n  })();\r\n\r\n  if (status !== 200) {\r\n    throw new MongoCryptAzureKMSRequestError('Unable to complete request.', body);\r\n  }\r\n\r\n  if (!body.access_token) {\r\n    throw new MongoCryptAzureKMSRequestError(\r\n      'Malformed response body - missing field `access_token`.'\r\n    );\r\n  }\r\n\r\n  if (!body.expires_in) {\r\n    throw new MongoCryptAzureKMSRequestError(\r\n      'Malformed response body - missing field `expires_in`.'\r\n    );\r\n  }\r\n\r\n  const expiresInMS = Number(body.expires_in) * 1000;\r\n  if (Number.isNaN(expiresInMS)) {\r\n    throw new MongoCryptAzureKMSRequestError(\r\n      'Malformed response body - unable to parse int from `expires_in` field.'\r\n    );\r\n  }\r\n\r\n  return {\r\n    accessToken: body.access_token,\r\n    expiresOnTimestamp: Date.now() + expiresInMS\r\n  };\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * exposed for CSFLE\r\n * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)\r\n */\r\nexport interface AzureKMSRequestOptions {\r\n  headers?: Document;\r\n  url?: URL | string;\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * parses any options provided by prose tests to `fetchAzureKMSToken` and merges them with\r\n * the default values for headers and the request url.\r\n */\r\nexport function prepareRequest(options: AzureKMSRequestOptions): {\r\n  headers: Document;\r\n  url: URL;\r\n} {\r\n  const url = new URL(\r\n    options.url?.toString() ?? 'http://169.254.169.254/metadata/identity/oauth2/token'\r\n  );\r\n\r\n  url.searchParams.append('api-version', '2018-02-01');\r\n  url.searchParams.append('resource', 'https://vault.azure.net');\r\n\r\n  const headers = { ...options.headers, 'Content-Type': 'application/json', Metadata: true };\r\n  return { headers, url };\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * `AzureKMSRequestOptions` allows prose tests to modify the http request sent to the idms\r\n * servers.  This is required to simulate different server conditions.  No options are expected to\r\n * be set outside of tests.\r\n *\r\n * exposed for CSFLE\r\n * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)\r\n */\r\nexport async function fetchAzureKMSToken(\r\n  options: AzureKMSRequestOptions = {}\r\n): Promise<AzureTokenCacheEntry> {\r\n  const { headers, url } = prepareRequest(options);\r\n  const response = await get(url, { headers }).catch(error => {\r\n    if (error instanceof MongoCryptKMSRequestNetworkTimeoutError) {\r\n      throw new MongoCryptAzureKMSRequestError(`[Azure KMS] ${error.message}`);\r\n    }\r\n    throw error;\r\n  });\r\n  return parseResponse(response);\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * @throws Will reject with a `MongoCryptError` if the http request fails or the http response is malformed.\r\n */\r\nexport async function loadAzureCredentials(kmsProviders: KMSProviders): Promise<KMSProviders> {\r\n  const azure = await tokenCache.getToken();\r\n  return { ...kmsProviders, azure };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}