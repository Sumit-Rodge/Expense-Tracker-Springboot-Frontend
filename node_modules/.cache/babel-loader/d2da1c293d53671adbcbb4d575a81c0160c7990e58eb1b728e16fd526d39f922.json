{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.onData = void 0;\nconst utils_1 = require(\"../../utils\");\n/**\r\n * onData is adapted from Node.js' events.on helper\r\n * https://nodejs.org/api/events.html#eventsonemitter-eventname-options\r\n *\r\n * Returns an AsyncIterator that iterates each 'data' event emitted from emitter.\r\n * It will reject upon an error event or if the provided signal is aborted.\r\n */\nfunction onData(emitter, options) {\n  const signal = options.signal;\n  // Setup pending events and pending promise lists\n  /**\r\n   * When the caller has not yet called .next(), we store the\r\n   * value from the event in this list. Next time they call .next()\r\n   * we pull the first value out of this list and resolve a promise with it.\r\n   */\n  const unconsumedEvents = new utils_1.List();\n  /**\r\n   * When there has not yet been an event, a new promise will be created\r\n   * and implicitly stored in this list. When an event occurs we take the first\r\n   * promise in this list and resolve it.\r\n   */\n  const unconsumedPromises = new utils_1.List();\n  /**\r\n   * Stored an error created by an error event.\r\n   * This error will turn into a rejection for the subsequent .next() call\r\n   */\n  let error = null;\n  /** Set to true only after event listeners have been removed. */\n  let finished = false;\n  const iterator = {\n    next() {\n      // First, we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value != null) {\n        return Promise.resolve({\n          value,\n          done: false\n        });\n      }\n      // Then we error, if an error happened\n      // This happens one time if at all, because after 'error'\n      // we stop listening\n      if (error != null) {\n        const p = Promise.reject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n      // If the iterator is finished, resolve to done\n      if (finished) return closeHandler();\n      // Wait until an event happens\n      const {\n        promise,\n        resolve,\n        reject\n      } = (0, utils_1.promiseWithResolvers)();\n      unconsumedPromises.push({\n        resolve,\n        reject\n      });\n      return promise;\n    },\n    return() {\n      return closeHandler();\n    },\n    throw(err) {\n      errorHandler(err);\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n  // Adding event handlers\n  emitter.on('data', eventHandler);\n  emitter.on('error', errorHandler);\n  if (signal.aborted) {\n    // If the signal is aborted, set up the first .next() call to be a rejection\n    queueMicrotask(abortListener);\n  } else {\n    signal.addEventListener('abort', abortListener, {\n      once: true\n    });\n  }\n  return iterator;\n  function abortListener() {\n    errorHandler(signal.reason);\n  }\n  function eventHandler(value) {\n    const promise = unconsumedPromises.shift();\n    if (promise != null) promise.resolve({\n      value,\n      done: false\n    });else unconsumedEvents.push(value);\n  }\n  function errorHandler(err) {\n    const promise = unconsumedPromises.shift();\n    if (promise != null) promise.reject(err);else error = err;\n    void closeHandler();\n  }\n  function closeHandler() {\n    // Adding event handlers\n    emitter.off('data', eventHandler);\n    emitter.off('error', errorHandler);\n    signal.removeEventListener('abort', abortListener);\n    finished = true;\n    const doneResult = {\n      value: undefined,\n      done: finished\n    };\n    for (const promise of unconsumedPromises) {\n      promise.resolve(doneResult);\n    }\n    return Promise.resolve(doneResult);\n  }\n}\nexports.onData = onData;","map":{"version":3,"names":["utils_1","require","onData","emitter","options","signal","unconsumedEvents","List","unconsumedPromises","error","finished","iterator","next","value","shift","Promise","resolve","done","p","reject","closeHandler","promise","promiseWithResolvers","push","return","throw","err","errorHandler","undefined","Symbol","asyncIterator","on","eventHandler","aborted","queueMicrotask","abortListener","addEventListener","once","reason","off","removeEventListener","doneResult","exports"],"sources":["C:\\Users\\sumit\\Desktop\\Final project\\Expense-Tracker-Springboot-Frontend\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\on_data.ts"],"sourcesContent":["import { type EventEmitter } from 'events';\r\n\r\nimport { List, promiseWithResolvers } from '../../utils';\r\n\r\n/**\r\n * @internal\r\n * An object holding references to a promise's resolve and reject functions.\r\n */\r\ntype PendingPromises = Omit<\r\n  ReturnType<typeof promiseWithResolvers<IteratorResult<Buffer>>>,\r\n  'promise'\r\n>;\r\n\r\n/**\r\n * onData is adapted from Node.js' events.on helper\r\n * https://nodejs.org/api/events.html#eventsonemitter-eventname-options\r\n *\r\n * Returns an AsyncIterator that iterates each 'data' event emitted from emitter.\r\n * It will reject upon an error event or if the provided signal is aborted.\r\n */\r\nexport function onData(emitter: EventEmitter, options: { signal: AbortSignal }) {\r\n  const signal = options.signal;\r\n\r\n  // Setup pending events and pending promise lists\r\n  /**\r\n   * When the caller has not yet called .next(), we store the\r\n   * value from the event in this list. Next time they call .next()\r\n   * we pull the first value out of this list and resolve a promise with it.\r\n   */\r\n  const unconsumedEvents = new List<Buffer>();\r\n  /**\r\n   * When there has not yet been an event, a new promise will be created\r\n   * and implicitly stored in this list. When an event occurs we take the first\r\n   * promise in this list and resolve it.\r\n   */\r\n  const unconsumedPromises = new List<PendingPromises>();\r\n\r\n  /**\r\n   * Stored an error created by an error event.\r\n   * This error will turn into a rejection for the subsequent .next() call\r\n   */\r\n  let error: Error | null = null;\r\n\r\n  /** Set to true only after event listeners have been removed. */\r\n  let finished = false;\r\n\r\n  const iterator: AsyncGenerator<Buffer> = {\r\n    next() {\r\n      // First, we consume all unread events\r\n      const value = unconsumedEvents.shift();\r\n      if (value != null) {\r\n        return Promise.resolve({ value, done: false });\r\n      }\r\n\r\n      // Then we error, if an error happened\r\n      // This happens one time if at all, because after 'error'\r\n      // we stop listening\r\n      if (error != null) {\r\n        const p = Promise.reject(error);\r\n        // Only the first element errors\r\n        error = null;\r\n        return p;\r\n      }\r\n\r\n      // If the iterator is finished, resolve to done\r\n      if (finished) return closeHandler();\r\n\r\n      // Wait until an event happens\r\n      const { promise, resolve, reject } = promiseWithResolvers<IteratorResult<Buffer>>();\r\n      unconsumedPromises.push({ resolve, reject });\r\n      return promise;\r\n    },\r\n\r\n    return() {\r\n      return closeHandler();\r\n    },\r\n\r\n    throw(err: Error) {\r\n      errorHandler(err);\r\n      return Promise.resolve({ value: undefined, done: true });\r\n    },\r\n\r\n    [Symbol.asyncIterator]() {\r\n      return this;\r\n    }\r\n  };\r\n\r\n  // Adding event handlers\r\n  emitter.on('data', eventHandler);\r\n  emitter.on('error', errorHandler);\r\n\r\n  if (signal.aborted) {\r\n    // If the signal is aborted, set up the first .next() call to be a rejection\r\n    queueMicrotask(abortListener);\r\n  } else {\r\n    signal.addEventListener('abort', abortListener, { once: true });\r\n  }\r\n\r\n  return iterator;\r\n\r\n  function abortListener() {\r\n    errorHandler(signal.reason);\r\n  }\r\n\r\n  function eventHandler(value: Buffer) {\r\n    const promise = unconsumedPromises.shift();\r\n    if (promise != null) promise.resolve({ value, done: false });\r\n    else unconsumedEvents.push(value);\r\n  }\r\n\r\n  function errorHandler(err: Error) {\r\n    const promise = unconsumedPromises.shift();\r\n    if (promise != null) promise.reject(err);\r\n    else error = err;\r\n    void closeHandler();\r\n  }\r\n\r\n  function closeHandler() {\r\n    // Adding event handlers\r\n    emitter.off('data', eventHandler);\r\n    emitter.off('error', errorHandler);\r\n    signal.removeEventListener('abort', abortListener);\r\n    finished = true;\r\n    const doneResult = { value: undefined, done: finished } as const;\r\n\r\n    for (const promise of unconsumedPromises) {\r\n      promise.resolve(doneResult);\r\n    }\r\n\r\n    return Promise.resolve(doneResult);\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}