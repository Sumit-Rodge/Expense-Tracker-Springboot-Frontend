{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\nconst error_1 = require(\"../error\");\nconst write_concern_1 = require(\"../write_concern\");\nconst bulk_write_1 = require(\"./bulk_write\");\nconst command_1 = require(\"./command\");\nconst common_functions_1 = require(\"./common_functions\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass InsertOperation extends command_1.CommandOperation {\n  constructor(ns, documents, options) {\n    super(undefined, options);\n    this.options = {\n      ...options,\n      checkKeys: options.checkKeys ?? false\n    };\n    this.ns = ns;\n    this.documents = documents;\n  }\n  get commandName() {\n    return 'insert';\n  }\n  async execute(server, session) {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n    return super.executeCommand(server, session, command);\n  }\n}\nexports.InsertOperation = InsertOperation;\nclass InsertOneOperation extends InsertOperation {\n  constructor(collection, doc, options) {\n    super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);\n  }\n  async execute(server, session) {\n    const res = await super.execute(server, session);\n    if (res.code) throw new error_1.MongoServerError(res);\n    if (res.writeErrors) {\n      // This should be a WriteError but we can't change it now because of error hierarchy\n      throw new error_1.MongoServerError(res.writeErrors[0]);\n    }\n    return {\n      acknowledged: this.writeConcern?.w !== 0,\n      insertedId: this.documents[0]._id\n    };\n  }\n}\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\nclass InsertManyOperation extends operation_1.AbstractOperation {\n  constructor(collection, docs, options) {\n    super(options);\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n  get commandName() {\n    return 'insert';\n  }\n  async execute(server, session) {\n    const coll = this.collection;\n    const options = {\n      ...this.options,\n      ...this.bsonOptions,\n      readPreference: this.readPreference\n    };\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(document => ({\n      insertOne: {\n        document\n      }\n    })), options);\n    try {\n      const res = await bulkWriteOperation.execute(server, session);\n      return {\n        acknowledged: writeConcern?.w !== 0,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      };\n    } catch (err) {\n      if (err && err.message === 'Operation must be an object with an operation key') {\n        throw new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');\n      }\n      throw err;\n    }\n  }\n}\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"names":["error_1","require","write_concern_1","bulk_write_1","command_1","common_functions_1","operation_1","InsertOperation","CommandOperation","constructor","ns","documents","options","undefined","checkKeys","commandName","execute","server","session","ordered","command","insert","collection","bypassDocumentValidation","comment","executeCommand","exports","InsertOneOperation","doc","s","namespace","prepareDocs","res","code","MongoServerError","writeErrors","acknowledged","writeConcern","w","insertedId","_id","InsertManyOperation","AbstractOperation","docs","Array","isArray","MongoInvalidArgumentError","coll","bsonOptions","readPreference","WriteConcern","fromOptions","bulkWriteOperation","BulkWriteOperation","map","document","insertOne","insertedCount","insertedIds","err","message","defineAspects","Aspect","RETRYABLE","WRITE_OPERATION"],"sources":["C:\\Users\\sumit\\Desktop\\Final project\\Expense-Tracker-Springboot-Frontend\\node_modules\\mongodb\\src\\operations\\insert.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport type { BulkWriteOptions } from '../bulk/common';\r\nimport type { Collection } from '../collection';\r\nimport { MongoInvalidArgumentError, MongoServerError } from '../error';\r\nimport type { InferIdType } from '../mongo_types';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport type { MongoDBNamespace } from '../utils';\r\nimport { WriteConcern } from '../write_concern';\r\nimport { BulkWriteOperation } from './bulk_write';\r\nimport { CommandOperation, type CommandOperationOptions } from './command';\r\nimport { prepareDocs } from './common_functions';\r\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\r\n\r\n/** @internal */\r\nexport class InsertOperation extends CommandOperation<Document> {\r\n  override options: BulkWriteOptions;\r\n  documents: Document[];\r\n\r\n  constructor(ns: MongoDBNamespace, documents: Document[], options: BulkWriteOptions) {\r\n    super(undefined, options);\r\n    this.options = { ...options, checkKeys: options.checkKeys ?? false };\r\n    this.ns = ns;\r\n    this.documents = documents;\r\n  }\r\n\r\n  override get commandName() {\r\n    return 'insert' as const;\r\n  }\r\n\r\n  override async execute(server: Server, session: ClientSession | undefined): Promise<Document> {\r\n    const options = this.options ?? {};\r\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\r\n    const command: Document = {\r\n      insert: this.ns.collection,\r\n      documents: this.documents,\r\n      ordered\r\n    };\r\n\r\n    if (typeof options.bypassDocumentValidation === 'boolean') {\r\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\r\n    }\r\n\r\n    // we check for undefined specifically here to allow falsy values\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    if (options.comment !== undefined) {\r\n      command.comment = options.comment;\r\n    }\r\n\r\n    return super.executeCommand(server, session, command);\r\n  }\r\n}\r\n\r\n/** @public */\r\nexport interface InsertOneOptions extends CommandOperationOptions {\r\n  /** Allow driver to bypass schema validation. */\r\n  bypassDocumentValidation?: boolean;\r\n  /** Force server to assign _id values instead of driver. */\r\n  forceServerObjectId?: boolean;\r\n}\r\n\r\n/** @public */\r\nexport interface InsertOneResult<TSchema = Document> {\r\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\r\n  acknowledged: boolean;\r\n  /** The identifier that was inserted. If the server generated the identifier, this value will be null as the driver does not have access to that data */\r\n  insertedId: InferIdType<TSchema>;\r\n}\r\n\r\nexport class InsertOneOperation extends InsertOperation {\r\n  constructor(collection: Collection, doc: Document, options: InsertOneOptions) {\r\n    super(collection.s.namespace, prepareDocs(collection, [doc], options), options);\r\n  }\r\n\r\n  override async execute(\r\n    server: Server,\r\n    session: ClientSession | undefined\r\n  ): Promise<InsertOneResult> {\r\n    const res = await super.execute(server, session);\r\n    if (res.code) throw new MongoServerError(res);\r\n    if (res.writeErrors) {\r\n      // This should be a WriteError but we can't change it now because of error hierarchy\r\n      throw new MongoServerError(res.writeErrors[0]);\r\n    }\r\n\r\n    return {\r\n      acknowledged: this.writeConcern?.w !== 0,\r\n      insertedId: this.documents[0]._id\r\n    };\r\n  }\r\n}\r\n\r\n/** @public */\r\nexport interface InsertManyResult<TSchema = Document> {\r\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\r\n  acknowledged: boolean;\r\n  /** The number of inserted documents for this operations */\r\n  insertedCount: number;\r\n  /** Map of the index of the inserted document to the id of the inserted document */\r\n  insertedIds: { [key: number]: InferIdType<TSchema> };\r\n}\r\n\r\n/** @internal */\r\nexport class InsertManyOperation extends AbstractOperation<InsertManyResult> {\r\n  override options: BulkWriteOptions;\r\n  collection: Collection;\r\n  docs: Document[];\r\n\r\n  constructor(collection: Collection, docs: Document[], options: BulkWriteOptions) {\r\n    super(options);\r\n\r\n    if (!Array.isArray(docs)) {\r\n      throw new MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\r\n    }\r\n\r\n    this.options = options;\r\n    this.collection = collection;\r\n    this.docs = docs;\r\n  }\r\n\r\n  override get commandName() {\r\n    return 'insert' as const;\r\n  }\r\n\r\n  override async execute(\r\n    server: Server,\r\n    session: ClientSession | undefined\r\n  ): Promise<InsertManyResult> {\r\n    const coll = this.collection;\r\n    const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };\r\n    const writeConcern = WriteConcern.fromOptions(options);\r\n    const bulkWriteOperation = new BulkWriteOperation(\r\n      coll,\r\n      prepareDocs(coll, this.docs, options).map(document => ({ insertOne: { document } })),\r\n      options\r\n    );\r\n\r\n    try {\r\n      const res = await bulkWriteOperation.execute(server, session);\r\n      return {\r\n        acknowledged: writeConcern?.w !== 0,\r\n        insertedCount: res.insertedCount,\r\n        insertedIds: res.insertedIds\r\n      };\r\n    } catch (err) {\r\n      if (err && err.message === 'Operation must be an object with an operation key') {\r\n        throw new MongoInvalidArgumentError(\r\n          'Collection.insertMany() cannot be called with an array that has null/undefined values'\r\n        );\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\ndefineAspects(InsertOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\r\ndefineAspects(InsertOneOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\r\ndefineAspects(InsertManyOperation, [Aspect.WRITE_OPERATION]);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}