{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientEncryption = void 0;\nconst bson_1 = require(\"../bson\");\nconst deps_1 = require(\"../deps\");\nconst utils_1 = require(\"../utils\");\nconst cryptoCallbacks = require(\"./crypto_callbacks\");\nconst errors_1 = require(\"./errors\");\nconst index_1 = require(\"./providers/index\");\nconst state_machine_1 = require(\"./state_machine\");\n/**\r\n * @public\r\n * The public interface for explicit in-use encryption\r\n */\nclass ClientEncryption {\n  /** @internal */\n  static getMongoCrypt() {\n    const encryption = (0, deps_1.getMongoDBClientEncryption)();\n    if ('kModuleError' in encryption) {\n      throw encryption.kModuleError;\n    }\n    return encryption.MongoCrypt;\n  }\n  /**\r\n   * Create a new encryption instance\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * new ClientEncryption(mongoClient, {\r\n   *   keyVaultNamespace: 'client.encryption',\r\n   *   kmsProviders: {\r\n   *     local: {\r\n   *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\r\n   *     }\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * new ClientEncryption(mongoClient, {\r\n   *   keyVaultNamespace: 'client.encryption',\r\n   *   kmsProviders: {\r\n   *     aws: {\r\n   *       accessKeyId: AWS_ACCESS_KEY,\r\n   *       secretAccessKey: AWS_SECRET_KEY\r\n   *     }\r\n   *   }\r\n   * });\r\n   * ```\r\n   */\n  constructor(client, options) {\n    this._client = client;\n    this._proxyOptions = options.proxyOptions ?? {};\n    this._tlsOptions = options.tlsOptions ?? {};\n    this._kmsProviders = options.kmsProviders || {};\n    if (options.keyVaultNamespace == null) {\n      throw new errors_1.MongoCryptInvalidArgumentError('Missing required option `keyVaultNamespace`');\n    }\n    const mongoCryptOptions = {\n      ...options,\n      cryptoCallbacks,\n      kmsProviders: !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders\n    };\n    this._keyVaultNamespace = options.keyVaultNamespace;\n    this._keyVaultClient = options.keyVaultClient || client;\n    const MongoCrypt = ClientEncryption.getMongoCrypt();\n    this._mongoCrypt = new MongoCrypt(mongoCryptOptions);\n  }\n  /**\r\n   * Creates a data key used for explicit encryption and inserts it into the key vault namespace\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Using async/await to create a local key\r\n   * const dataKeyId = await clientEncryption.createDataKey('local');\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Using async/await to create an aws key\r\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\r\n   *   masterKey: {\r\n   *     region: 'us-east-1',\r\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Using async/await to create an aws key with a keyAltName\r\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\r\n   *   masterKey: {\r\n   *     region: 'us-east-1',\r\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\r\n   *   },\r\n   *   keyAltNames: [ 'mySpecialKey' ]\r\n   * });\r\n   * ```\r\n   */\n  async createDataKey(provider, options = {}) {\n    if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {\n      throw new errors_1.MongoCryptInvalidArgumentError(`Option \"keyAltNames\" must be an array of strings, but was of type ${typeof options.keyAltNames}.`);\n    }\n    let keyAltNames = undefined;\n    if (options.keyAltNames && options.keyAltNames.length > 0) {\n      keyAltNames = options.keyAltNames.map((keyAltName, i) => {\n        if (typeof keyAltName !== 'string') {\n          throw new errors_1.MongoCryptInvalidArgumentError(`Option \"keyAltNames\" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);\n        }\n        return (0, bson_1.serialize)({\n          keyAltName\n        });\n      });\n    }\n    let keyMaterial = undefined;\n    if (options.keyMaterial) {\n      keyMaterial = (0, bson_1.serialize)({\n        keyMaterial: options.keyMaterial\n      });\n    }\n    const dataKeyBson = (0, bson_1.serialize)({\n      provider,\n      ...options.masterKey\n    });\n    const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {\n      keyAltNames,\n      keyMaterial\n    });\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const dataKey = await stateMachine.execute(this, context);\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const {\n      insertedId\n    } = await this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {\n      writeConcern: {\n        w: 'majority'\n      }\n    });\n    return insertedId;\n  }\n  /**\r\n   * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.\r\n   *\r\n   * If no matches are found, then no bulk write is performed.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // rewrapping all data data keys (using a filter that matches all documents)\r\n   * const filter = {};\r\n   *\r\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\r\n   * if (result.bulkWriteResult != null) {\r\n   *  // keys were re-wrapped, results will be available in the bulkWrite object.\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // attempting to rewrap all data keys with no matches\r\n   * const filter = { _id: new Binary() } // assume _id matches no documents in the database\r\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\r\n   *\r\n   * if (result.bulkWriteResult == null) {\r\n   *  // no keys matched, `bulkWriteResult` does not exist on the result object\r\n   * }\r\n   * ```\r\n   */\n  async rewrapManyDataKey(filter, options) {\n    let keyEncryptionKeyBson = undefined;\n    if (options) {\n      const keyEncryptionKey = Object.assign({\n        provider: options.provider\n      }, options.masterKey);\n      keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);\n    }\n    const filterBson = (0, bson_1.serialize)(filter);\n    const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const {\n      v: dataKeys\n    } = await stateMachine.execute(this, context);\n    if (dataKeys.length === 0) {\n      return {};\n    }\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const replacements = dataKeys.map(key => ({\n      updateOne: {\n        filter: {\n          _id: key._id\n        },\n        update: {\n          $set: {\n            masterKey: key.masterKey,\n            keyMaterial: key.keyMaterial\n          },\n          $currentDate: {\n            updateDate: true\n          }\n        }\n      }\n    }));\n    const result = await this._keyVaultClient.db(dbName).collection(collectionName).bulkWrite(replacements, {\n      writeConcern: {\n        w: 'majority'\n      }\n    });\n    return {\n      bulkWriteResult: result\n    };\n  }\n  /**\r\n   * Deletes the key with the provided id from the keyvault, if it exists.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // delete a key by _id\r\n   * const id = new Binary(); // id is a bson binary subtype 4 object\r\n   * const { deletedCount } = await clientEncryption.deleteKey(id);\r\n   *\r\n   * if (deletedCount != null && deletedCount > 0) {\r\n   *   // successful deletion\r\n   * }\r\n   * ```\r\n   *\r\n   */\n  async deleteKey(_id) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return this._keyVaultClient.db(dbName).collection(collectionName).deleteOne({\n      _id\n    }, {\n      writeConcern: {\n        w: 'majority'\n      }\n    });\n  }\n  /**\r\n   * Finds all the keys currently stored in the keyvault.\r\n   *\r\n   * This method will not throw.\r\n   *\r\n   * @returns a FindCursor over all keys in the keyvault.\r\n   * @example\r\n   * ```ts\r\n   * // fetching all keys\r\n   * const keys = await clientEncryption.getKeys().toArray();\r\n   * ```\r\n   */\n  getKeys() {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return this._keyVaultClient.db(dbName).collection(collectionName).find({}, {\n      readConcern: {\n        level: 'majority'\n      }\n    });\n  }\n  /**\r\n   * Finds a key in the keyvault with the specified _id.\r\n   *\r\n   * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\r\n   * match the id.  The promise rejects with an error if an error is thrown.\r\n   * @example\r\n   * ```ts\r\n   * // getting a key by id\r\n   * const id = new Binary(); // id is a bson binary subtype 4 object\r\n   * const key = await clientEncryption.getKey(id);\r\n   * if (!key) {\r\n   *  // key is null if there was no matching key\r\n   * }\r\n   * ```\r\n   */\n  async getKey(_id) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return this._keyVaultClient.db(dbName).collection(collectionName).findOne({\n      _id\n    }, {\n      readConcern: {\n        level: 'majority'\n      }\n    });\n  }\n  /**\r\n   * Finds a key in the keyvault which has the specified keyAltName.\r\n   *\r\n   * @param keyAltName - a keyAltName to search for a key\r\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\r\n   * match the keyAltName.  The promise rejects with an error if an error is thrown.\r\n   * @example\r\n   * ```ts\r\n   * // get a key by alt name\r\n   * const keyAltName = 'keyAltName';\r\n   * const key = await clientEncryption.getKeyByAltName(keyAltName);\r\n   * if (!key) {\r\n   *  // key is null if there is no matching key\r\n   * }\r\n   * ```\r\n   */\n  async getKeyByAltName(keyAltName) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return this._keyVaultClient.db(dbName).collection(collectionName).findOne({\n      keyAltNames: keyAltName\n    }, {\n      readConcern: {\n        level: 'majority'\n      }\n    });\n  }\n  /**\r\n   * Adds a keyAltName to a key identified by the provided _id.\r\n   *\r\n   * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).\r\n   *\r\n   * @param _id - The id of the document to update.\r\n   * @param keyAltName - a keyAltName to search for a key\r\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\r\n   * match the id.  The promise rejects with an error if an error is thrown.\r\n   * @example\r\n   * ```ts\r\n   * // adding an keyAltName to a data key\r\n   * const id = new Binary();  // id is a bson binary subtype 4 object\r\n   * const keyAltName = 'keyAltName';\r\n   * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);\r\n   * if (!oldKey) {\r\n   *  // null is returned if there is no matching document with an id matching the supplied id\r\n   * }\r\n   * ```\r\n   */\n  async addKeyAltName(_id, keyAltName) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({\n      _id\n    }, {\n      $addToSet: {\n        keyAltNames: keyAltName\n      }\n    }, {\n      writeConcern: {\n        w: 'majority'\n      },\n      returnDocument: 'before'\n    });\n    return value;\n  }\n  /**\r\n   * Adds a keyAltName to a key identified by the provided _id.\r\n   *\r\n   * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).\r\n   *\r\n   * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.\r\n   *\r\n   * @param _id - The id of the document to update.\r\n   * @param keyAltName - a keyAltName to search for a key\r\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\r\n   * match the id.  The promise rejects with an error if an error is thrown.\r\n   * @example\r\n   * ```ts\r\n   * // removing a key alt name from a data key\r\n   * const id = new Binary();  // id is a bson binary subtype 4 object\r\n   * const keyAltName = 'keyAltName';\r\n   * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);\r\n   *\r\n   * if (!oldKey) {\r\n   *  // null is returned if there is no matching document with an id matching the supplied id\r\n   * }\r\n   * ```\r\n   */\n  async removeKeyAltName(_id, keyAltName) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const pipeline = [{\n      $set: {\n        keyAltNames: {\n          $cond: [{\n            $eq: ['$keyAltNames', [keyAltName]]\n          }, '$$REMOVE', {\n            $filter: {\n              input: '$keyAltNames',\n              cond: {\n                $ne: ['$$this', keyAltName]\n              }\n            }\n          }]\n        }\n      }\n    }];\n    const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({\n      _id\n    }, pipeline, {\n      writeConcern: {\n        w: 'majority'\n      },\n      returnDocument: 'before'\n    });\n    return value;\n  }\n  /**\r\n   * A convenience method for creating an encrypted collection.\r\n   * This method will create data keys for any encryptedFields that do not have a `keyId` defined\r\n   * and then create a new collection with the full set of encryptedFields.\r\n   *\r\n   * @param db - A Node.js driver Db object with which to create the collection\r\n   * @param name - The name of the collection to be created\r\n   * @param options - Options for createDataKey and for createCollection\r\n   * @returns created collection and generated encryptedFields\r\n   * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.\r\n   * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.\r\n   */\n  async createEncryptedCollection(db, name, options) {\n    const {\n      provider,\n      masterKey,\n      createCollectionOptions: {\n        encryptedFields: {\n          ...encryptedFields\n        },\n        ...createCollectionOptions\n      }\n    } = options;\n    if (Array.isArray(encryptedFields.fields)) {\n      const createDataKeyPromises = encryptedFields.fields.map(async field => field == null || typeof field !== 'object' || field.keyId != null ? field : {\n        ...field,\n        keyId: await this.createDataKey(provider, {\n          masterKey\n        })\n      });\n      const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);\n      encryptedFields.fields = createDataKeyResolutions.map((resolution, index) => resolution.status === 'fulfilled' ? resolution.value : encryptedFields.fields[index]);\n      const rejection = createDataKeyResolutions.find(result => result.status === 'rejected');\n      if (rejection != null) {\n        throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, {\n          cause: rejection.reason\n        });\n      }\n    }\n    try {\n      const collection = await db.createCollection(name, {\n        ...createCollectionOptions,\n        encryptedFields\n      });\n      return {\n        collection,\n        encryptedFields\n      };\n    } catch (cause) {\n      throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, {\n        cause\n      });\n    }\n  }\n  /**\r\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\r\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\r\n   *\r\n   * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON\r\n   * @param options -\r\n   * @returns a Promise that either resolves with the encrypted value, or rejects with an error.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Encryption with async/await api\r\n   * async function encryptMyData(value) {\r\n   *   const keyId = await clientEncryption.createDataKey('local');\r\n   *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Encryption using a keyAltName\r\n   * async function encryptMyData(value) {\r\n   *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\r\n   *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\r\n   * }\r\n   * ```\r\n   */\n  async encrypt(value, options) {\n    return this._encrypt(value, false, options);\n  }\n  /**\r\n   * Encrypts a Match Expression or Aggregate Expression to query a range index.\r\n   *\r\n   * Only supported when queryType is \"rangePreview\" and algorithm is \"RangePreview\".\r\n   *\r\n   * @experimental The Range algorithm is experimental only. It is not intended for production use. It is subject to breaking changes.\r\n   *\r\n   * @param expression - a BSON document of one of the following forms:\r\n   *  1. A Match Expression of this form:\r\n   *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`\r\n   *  2. An Aggregate Expression of this form:\r\n   *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`\r\n   *\r\n   *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.\r\n   *\r\n   * @param options -\r\n   * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.\r\n   */\n  async encryptExpression(expression, options) {\n    return this._encrypt(expression, true, options);\n  }\n  /**\r\n   * Explicitly decrypt a provided encrypted value\r\n   *\r\n   * @param value - An encrypted value\r\n   * @returns a Promise that either resolves with the decrypted value, or rejects with an error\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Decrypting value with async/await API\r\n   * async function decryptMyValue(value) {\r\n   *   return clientEncryption.decrypt(value);\r\n   * }\r\n   * ```\r\n   */\n  async decrypt(value) {\n    const valueBuffer = (0, bson_1.serialize)({\n      v: value\n    });\n    const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const {\n      v\n    } = await stateMachine.execute(this, context);\n    return v;\n  }\n  /**\r\n   * @internal\r\n   * Ask the user for KMS credentials.\r\n   *\r\n   * This returns anything that looks like the kmsProviders original input\r\n   * option. It can be empty, and any provider specified here will override\r\n   * the original ones.\r\n   */\n  async askForKMSCredentials() {\n    return (0, index_1.refreshKMSCredentials)(this._kmsProviders);\n  }\n  static get libmongocryptVersion() {\n    return ClientEncryption.getMongoCrypt().libmongocryptVersion;\n  }\n  /**\r\n   * @internal\r\n   * A helper that perform explicit encryption of values and expressions.\r\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\r\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\r\n   *\r\n   * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON\r\n   * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression\r\n   * @param options - options to pass to encrypt\r\n   * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return\r\n   *          value will be a bson document.  When false, the value will be a BSON Binary.\r\n   *\r\n   */\n  async _encrypt(value, expressionMode, options) {\n    const {\n      algorithm,\n      keyId,\n      keyAltName,\n      contentionFactor,\n      queryType,\n      rangeOptions\n    } = options;\n    const contextOptions = {\n      expressionMode,\n      algorithm\n    };\n    if (keyId) {\n      contextOptions.keyId = keyId.buffer;\n    }\n    if (keyAltName) {\n      if (keyId) {\n        throw new errors_1.MongoCryptInvalidArgumentError(`\"options\" cannot contain both \"keyId\" and \"keyAltName\"`);\n      }\n      if (typeof keyAltName !== 'string') {\n        throw new errors_1.MongoCryptInvalidArgumentError(`\"options.keyAltName\" must be of type string, but was of type ${typeof keyAltName}`);\n      }\n      contextOptions.keyAltName = (0, bson_1.serialize)({\n        keyAltName\n      });\n    }\n    if (typeof contentionFactor === 'number' || typeof contentionFactor === 'bigint') {\n      contextOptions.contentionFactor = contentionFactor;\n    }\n    if (typeof queryType === 'string') {\n      contextOptions.queryType = queryType;\n    }\n    if (typeof rangeOptions === 'object') {\n      contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);\n    }\n    const valueBuffer = (0, bson_1.serialize)({\n      v: value\n    });\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n    const result = await stateMachine.execute(this, context);\n    return result.v;\n  }\n}\nexports.ClientEncryption = ClientEncryption;","map":{"version":3,"names":["bson_1","require","deps_1","utils_1","cryptoCallbacks","errors_1","index_1","state_machine_1","ClientEncryption","getMongoCrypt","encryption","getMongoDBClientEncryption","kModuleError","MongoCrypt","constructor","client","options","_client","_proxyOptions","proxyOptions","_tlsOptions","tlsOptions","_kmsProviders","kmsProviders","keyVaultNamespace","MongoCryptInvalidArgumentError","mongoCryptOptions","Buffer","isBuffer","serialize","_keyVaultNamespace","_keyVaultClient","keyVaultClient","_mongoCrypt","createDataKey","provider","keyAltNames","Array","isArray","undefined","length","map","keyAltName","i","keyMaterial","dataKeyBson","masterKey","context","makeDataKeyContext","stateMachine","StateMachine","dataKey","execute","db","dbName","collection","collectionName","MongoDBCollectionNamespace","fromString","insertedId","insertOne","writeConcern","w","rewrapManyDataKey","filter","keyEncryptionKeyBson","keyEncryptionKey","Object","assign","filterBson","makeRewrapManyDataKeyContext","v","dataKeys","replacements","key","updateOne","_id","update","$set","$currentDate","updateDate","result","bulkWrite","bulkWriteResult","deleteKey","deleteOne","getKeys","find","readConcern","level","getKey","findOne","getKeyByAltName","addKeyAltName","value","findOneAndUpdate","$addToSet","returnDocument","removeKeyAltName","pipeline","$cond","$eq","$filter","input","cond","$ne","createEncryptedCollection","name","createCollectionOptions","encryptedFields","fields","createDataKeyPromises","field","keyId","createDataKeyResolutions","Promise","allSettled","resolution","index","status","rejection","MongoCryptCreateDataKeyError","cause","reason","createCollection","MongoCryptCreateEncryptedCollectionError","encrypt","_encrypt","encryptExpression","expression","decrypt","valueBuffer","makeExplicitDecryptionContext","askForKMSCredentials","refreshKMSCredentials","libmongocryptVersion","expressionMode","algorithm","contentionFactor","queryType","rangeOptions","contextOptions","buffer","makeExplicitEncryptionContext","exports"],"sources":["C:\\Users\\sumit\\Desktop\\Final project\\Expense-Tracker-Springboot-Frontend\\node_modules\\mongodb\\src\\client-side-encryption\\client_encryption.ts"],"sourcesContent":["import type {\r\n  ExplicitEncryptionContextOptions,\r\n  MongoCrypt,\r\n  MongoCryptConstructor,\r\n  MongoCryptOptions\r\n} from 'mongodb-client-encryption';\r\n\r\nimport { type Binary, type Document, type Long, serialize, type UUID } from '../bson';\r\nimport { type AnyBulkWriteOperation, type BulkWriteResult } from '../bulk/common';\r\nimport { type ProxyOptions } from '../cmap/connection';\r\nimport { type Collection } from '../collection';\r\nimport { type FindCursor } from '../cursor/find_cursor';\r\nimport { type Db } from '../db';\r\nimport { getMongoDBClientEncryption } from '../deps';\r\nimport { type MongoClient } from '../mongo_client';\r\nimport { type Filter, type WithId } from '../mongo_types';\r\nimport { type CreateCollectionOptions } from '../operations/create_collection';\r\nimport { type DeleteResult } from '../operations/delete';\r\nimport { MongoDBCollectionNamespace } from '../utils';\r\nimport * as cryptoCallbacks from './crypto_callbacks';\r\nimport {\r\n  MongoCryptCreateDataKeyError,\r\n  MongoCryptCreateEncryptedCollectionError,\r\n  MongoCryptInvalidArgumentError\r\n} from './errors';\r\nimport {\r\n  type ClientEncryptionDataKeyProvider,\r\n  type KMSProviders,\r\n  refreshKMSCredentials\r\n} from './providers/index';\r\nimport { type CSFLEKMSTlsOptions, StateMachine } from './state_machine';\r\n\r\n/**\r\n * @public\r\n * The schema for a DataKey in the key vault collection.\r\n */\r\nexport interface DataKey {\r\n  _id: UUID;\r\n  version?: number;\r\n  keyAltNames?: string[];\r\n  keyMaterial: Binary;\r\n  creationDate: Date;\r\n  updateDate: Date;\r\n  status: number;\r\n  masterKey: Document;\r\n}\r\n\r\n/**\r\n * @public\r\n * The public interface for explicit in-use encryption\r\n */\r\nexport class ClientEncryption {\r\n  /** @internal */\r\n  _client: MongoClient;\r\n  /** @internal */\r\n  _keyVaultNamespace: string;\r\n  /** @internal */\r\n  _keyVaultClient: MongoClient;\r\n  /** @internal */\r\n  _proxyOptions: ProxyOptions;\r\n  /** @internal */\r\n  _tlsOptions: CSFLEKMSTlsOptions;\r\n  /** @internal */\r\n  _kmsProviders: KMSProviders;\r\n\r\n  /** @internal */\r\n  _mongoCrypt: MongoCrypt;\r\n\r\n  /** @internal */\r\n  static getMongoCrypt(): MongoCryptConstructor {\r\n    const encryption = getMongoDBClientEncryption();\r\n    if ('kModuleError' in encryption) {\r\n      throw encryption.kModuleError;\r\n    }\r\n    return encryption.MongoCrypt;\r\n  }\r\n\r\n  /**\r\n   * Create a new encryption instance\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * new ClientEncryption(mongoClient, {\r\n   *   keyVaultNamespace: 'client.encryption',\r\n   *   kmsProviders: {\r\n   *     local: {\r\n   *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\r\n   *     }\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * new ClientEncryption(mongoClient, {\r\n   *   keyVaultNamespace: 'client.encryption',\r\n   *   kmsProviders: {\r\n   *     aws: {\r\n   *       accessKeyId: AWS_ACCESS_KEY,\r\n   *       secretAccessKey: AWS_SECRET_KEY\r\n   *     }\r\n   *   }\r\n   * });\r\n   * ```\r\n   */\r\n  constructor(client: MongoClient, options: ClientEncryptionOptions) {\r\n    this._client = client;\r\n    this._proxyOptions = options.proxyOptions ?? {};\r\n    this._tlsOptions = options.tlsOptions ?? {};\r\n    this._kmsProviders = options.kmsProviders || {};\r\n\r\n    if (options.keyVaultNamespace == null) {\r\n      throw new MongoCryptInvalidArgumentError('Missing required option `keyVaultNamespace`');\r\n    }\r\n\r\n    const mongoCryptOptions: MongoCryptOptions = {\r\n      ...options,\r\n      cryptoCallbacks,\r\n      kmsProviders: !Buffer.isBuffer(this._kmsProviders)\r\n        ? (serialize(this._kmsProviders) as Buffer)\r\n        : this._kmsProviders\r\n    };\r\n\r\n    this._keyVaultNamespace = options.keyVaultNamespace;\r\n    this._keyVaultClient = options.keyVaultClient || client;\r\n    const MongoCrypt = ClientEncryption.getMongoCrypt();\r\n    this._mongoCrypt = new MongoCrypt(mongoCryptOptions);\r\n  }\r\n\r\n  /**\r\n   * Creates a data key used for explicit encryption and inserts it into the key vault namespace\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Using async/await to create a local key\r\n   * const dataKeyId = await clientEncryption.createDataKey('local');\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Using async/await to create an aws key\r\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\r\n   *   masterKey: {\r\n   *     region: 'us-east-1',\r\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Using async/await to create an aws key with a keyAltName\r\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\r\n   *   masterKey: {\r\n   *     region: 'us-east-1',\r\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\r\n   *   },\r\n   *   keyAltNames: [ 'mySpecialKey' ]\r\n   * });\r\n   * ```\r\n   */\r\n  async createDataKey(\r\n    provider: ClientEncryptionDataKeyProvider,\r\n    options: ClientEncryptionCreateDataKeyProviderOptions = {}\r\n  ): Promise<UUID> {\r\n    if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {\r\n      throw new MongoCryptInvalidArgumentError(\r\n        `Option \"keyAltNames\" must be an array of strings, but was of type ${typeof options.keyAltNames}.`\r\n      );\r\n    }\r\n\r\n    let keyAltNames = undefined;\r\n    if (options.keyAltNames && options.keyAltNames.length > 0) {\r\n      keyAltNames = options.keyAltNames.map((keyAltName, i) => {\r\n        if (typeof keyAltName !== 'string') {\r\n          throw new MongoCryptInvalidArgumentError(\r\n            `Option \"keyAltNames\" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`\r\n          );\r\n        }\r\n\r\n        return serialize({ keyAltName });\r\n      });\r\n    }\r\n\r\n    let keyMaterial = undefined;\r\n    if (options.keyMaterial) {\r\n      keyMaterial = serialize({ keyMaterial: options.keyMaterial });\r\n    }\r\n\r\n    const dataKeyBson = serialize({\r\n      provider,\r\n      ...options.masterKey\r\n    });\r\n\r\n    const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {\r\n      keyAltNames,\r\n      keyMaterial\r\n    });\r\n\r\n    const stateMachine = new StateMachine({\r\n      proxyOptions: this._proxyOptions,\r\n      tlsOptions: this._tlsOptions\r\n    });\r\n\r\n    const dataKey = await stateMachine.execute<DataKey>(this, context);\r\n\r\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\r\n      this._keyVaultNamespace\r\n    );\r\n\r\n    const { insertedId } = await this._keyVaultClient\r\n      .db(dbName)\r\n      .collection<DataKey>(collectionName)\r\n      .insertOne(dataKey, { writeConcern: { w: 'majority' } });\r\n\r\n    return insertedId;\r\n  }\r\n\r\n  /**\r\n   * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.\r\n   *\r\n   * If no matches are found, then no bulk write is performed.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // rewrapping all data data keys (using a filter that matches all documents)\r\n   * const filter = {};\r\n   *\r\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\r\n   * if (result.bulkWriteResult != null) {\r\n   *  // keys were re-wrapped, results will be available in the bulkWrite object.\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // attempting to rewrap all data keys with no matches\r\n   * const filter = { _id: new Binary() } // assume _id matches no documents in the database\r\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\r\n   *\r\n   * if (result.bulkWriteResult == null) {\r\n   *  // no keys matched, `bulkWriteResult` does not exist on the result object\r\n   * }\r\n   * ```\r\n   */\r\n  async rewrapManyDataKey(\r\n    filter: Filter<DataKey>,\r\n    options: ClientEncryptionRewrapManyDataKeyProviderOptions\r\n  ): Promise<{ bulkWriteResult?: BulkWriteResult }> {\r\n    let keyEncryptionKeyBson = undefined;\r\n    if (options) {\r\n      const keyEncryptionKey = Object.assign({ provider: options.provider }, options.masterKey);\r\n      keyEncryptionKeyBson = serialize(keyEncryptionKey);\r\n    }\r\n    const filterBson = serialize(filter);\r\n    const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);\r\n    const stateMachine = new StateMachine({\r\n      proxyOptions: this._proxyOptions,\r\n      tlsOptions: this._tlsOptions\r\n    });\r\n\r\n    const { v: dataKeys } = await stateMachine.execute<{ v: DataKey[] }>(this, context);\r\n    if (dataKeys.length === 0) {\r\n      return {};\r\n    }\r\n\r\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\r\n      this._keyVaultNamespace\r\n    );\r\n\r\n    const replacements = dataKeys.map(\r\n      (key: DataKey): AnyBulkWriteOperation<DataKey> => ({\r\n        updateOne: {\r\n          filter: { _id: key._id },\r\n          update: {\r\n            $set: {\r\n              masterKey: key.masterKey,\r\n              keyMaterial: key.keyMaterial\r\n            },\r\n            $currentDate: {\r\n              updateDate: true\r\n            }\r\n          }\r\n        }\r\n      })\r\n    );\r\n\r\n    const result = await this._keyVaultClient\r\n      .db(dbName)\r\n      .collection<DataKey>(collectionName)\r\n      .bulkWrite(replacements, {\r\n        writeConcern: { w: 'majority' }\r\n      });\r\n\r\n    return { bulkWriteResult: result };\r\n  }\r\n\r\n  /**\r\n   * Deletes the key with the provided id from the keyvault, if it exists.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // delete a key by _id\r\n   * const id = new Binary(); // id is a bson binary subtype 4 object\r\n   * const { deletedCount } = await clientEncryption.deleteKey(id);\r\n   *\r\n   * if (deletedCount != null && deletedCount > 0) {\r\n   *   // successful deletion\r\n   * }\r\n   * ```\r\n   *\r\n   */\r\n  async deleteKey(_id: Binary): Promise<DeleteResult> {\r\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\r\n      this._keyVaultNamespace\r\n    );\r\n\r\n    return this._keyVaultClient\r\n      .db(dbName)\r\n      .collection<DataKey>(collectionName)\r\n      .deleteOne({ _id }, { writeConcern: { w: 'majority' } });\r\n  }\r\n\r\n  /**\r\n   * Finds all the keys currently stored in the keyvault.\r\n   *\r\n   * This method will not throw.\r\n   *\r\n   * @returns a FindCursor over all keys in the keyvault.\r\n   * @example\r\n   * ```ts\r\n   * // fetching all keys\r\n   * const keys = await clientEncryption.getKeys().toArray();\r\n   * ```\r\n   */\r\n  getKeys(): FindCursor<DataKey> {\r\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\r\n      this._keyVaultNamespace\r\n    );\r\n\r\n    return this._keyVaultClient\r\n      .db(dbName)\r\n      .collection<DataKey>(collectionName)\r\n      .find({}, { readConcern: { level: 'majority' } });\r\n  }\r\n\r\n  /**\r\n   * Finds a key in the keyvault with the specified _id.\r\n   *\r\n   * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\r\n   * match the id.  The promise rejects with an error if an error is thrown.\r\n   * @example\r\n   * ```ts\r\n   * // getting a key by id\r\n   * const id = new Binary(); // id is a bson binary subtype 4 object\r\n   * const key = await clientEncryption.getKey(id);\r\n   * if (!key) {\r\n   *  // key is null if there was no matching key\r\n   * }\r\n   * ```\r\n   */\r\n  async getKey(_id: Binary): Promise<DataKey | null> {\r\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\r\n      this._keyVaultNamespace\r\n    );\r\n\r\n    return this._keyVaultClient\r\n      .db(dbName)\r\n      .collection<DataKey>(collectionName)\r\n      .findOne({ _id }, { readConcern: { level: 'majority' } });\r\n  }\r\n\r\n  /**\r\n   * Finds a key in the keyvault which has the specified keyAltName.\r\n   *\r\n   * @param keyAltName - a keyAltName to search for a key\r\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\r\n   * match the keyAltName.  The promise rejects with an error if an error is thrown.\r\n   * @example\r\n   * ```ts\r\n   * // get a key by alt name\r\n   * const keyAltName = 'keyAltName';\r\n   * const key = await clientEncryption.getKeyByAltName(keyAltName);\r\n   * if (!key) {\r\n   *  // key is null if there is no matching key\r\n   * }\r\n   * ```\r\n   */\r\n  async getKeyByAltName(keyAltName: string): Promise<WithId<DataKey> | null> {\r\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\r\n      this._keyVaultNamespace\r\n    );\r\n\r\n    return this._keyVaultClient\r\n      .db(dbName)\r\n      .collection<DataKey>(collectionName)\r\n      .findOne({ keyAltNames: keyAltName }, { readConcern: { level: 'majority' } });\r\n  }\r\n\r\n  /**\r\n   * Adds a keyAltName to a key identified by the provided _id.\r\n   *\r\n   * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).\r\n   *\r\n   * @param _id - The id of the document to update.\r\n   * @param keyAltName - a keyAltName to search for a key\r\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\r\n   * match the id.  The promise rejects with an error if an error is thrown.\r\n   * @example\r\n   * ```ts\r\n   * // adding an keyAltName to a data key\r\n   * const id = new Binary();  // id is a bson binary subtype 4 object\r\n   * const keyAltName = 'keyAltName';\r\n   * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);\r\n   * if (!oldKey) {\r\n   *  // null is returned if there is no matching document with an id matching the supplied id\r\n   * }\r\n   * ```\r\n   */\r\n  async addKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null> {\r\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\r\n      this._keyVaultNamespace\r\n    );\r\n\r\n    const value = await this._keyVaultClient\r\n      .db(dbName)\r\n      .collection<DataKey>(collectionName)\r\n      .findOneAndUpdate(\r\n        { _id },\r\n        { $addToSet: { keyAltNames: keyAltName } },\r\n        { writeConcern: { w: 'majority' }, returnDocument: 'before' }\r\n      );\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Adds a keyAltName to a key identified by the provided _id.\r\n   *\r\n   * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).\r\n   *\r\n   * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.\r\n   *\r\n   * @param _id - The id of the document to update.\r\n   * @param keyAltName - a keyAltName to search for a key\r\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\r\n   * match the id.  The promise rejects with an error if an error is thrown.\r\n   * @example\r\n   * ```ts\r\n   * // removing a key alt name from a data key\r\n   * const id = new Binary();  // id is a bson binary subtype 4 object\r\n   * const keyAltName = 'keyAltName';\r\n   * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);\r\n   *\r\n   * if (!oldKey) {\r\n   *  // null is returned if there is no matching document with an id matching the supplied id\r\n   * }\r\n   * ```\r\n   */\r\n  async removeKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null> {\r\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\r\n      this._keyVaultNamespace\r\n    );\r\n\r\n    const pipeline = [\r\n      {\r\n        $set: {\r\n          keyAltNames: {\r\n            $cond: [\r\n              {\r\n                $eq: ['$keyAltNames', [keyAltName]]\r\n              },\r\n              '$$REMOVE',\r\n              {\r\n                $filter: {\r\n                  input: '$keyAltNames',\r\n                  cond: {\r\n                    $ne: ['$$this', keyAltName]\r\n                  }\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        }\r\n      }\r\n    ];\r\n    const value = await this._keyVaultClient\r\n      .db(dbName)\r\n      .collection<DataKey>(collectionName)\r\n      .findOneAndUpdate({ _id }, pipeline, {\r\n        writeConcern: { w: 'majority' },\r\n        returnDocument: 'before'\r\n      });\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * A convenience method for creating an encrypted collection.\r\n   * This method will create data keys for any encryptedFields that do not have a `keyId` defined\r\n   * and then create a new collection with the full set of encryptedFields.\r\n   *\r\n   * @param db - A Node.js driver Db object with which to create the collection\r\n   * @param name - The name of the collection to be created\r\n   * @param options - Options for createDataKey and for createCollection\r\n   * @returns created collection and generated encryptedFields\r\n   * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.\r\n   * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.\r\n   */\r\n  async createEncryptedCollection<TSchema extends Document = Document>(\r\n    db: Db,\r\n    name: string,\r\n    options: {\r\n      provider: ClientEncryptionDataKeyProvider;\r\n      createCollectionOptions: Omit<CreateCollectionOptions, 'encryptedFields'> & {\r\n        encryptedFields: Document;\r\n      };\r\n      masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions;\r\n    }\r\n  ): Promise<{ collection: Collection<TSchema>; encryptedFields: Document }> {\r\n    const {\r\n      provider,\r\n      masterKey,\r\n      createCollectionOptions: {\r\n        encryptedFields: { ...encryptedFields },\r\n        ...createCollectionOptions\r\n      }\r\n    } = options;\r\n\r\n    if (Array.isArray(encryptedFields.fields)) {\r\n      const createDataKeyPromises = encryptedFields.fields.map(async field =>\r\n        field == null || typeof field !== 'object' || field.keyId != null\r\n          ? field\r\n          : {\r\n              ...field,\r\n              keyId: await this.createDataKey(provider, { masterKey })\r\n            }\r\n      );\r\n\r\n      const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);\r\n\r\n      encryptedFields.fields = createDataKeyResolutions.map((resolution, index) =>\r\n        resolution.status === 'fulfilled' ? resolution.value : encryptedFields.fields[index]\r\n      );\r\n\r\n      const rejection = createDataKeyResolutions.find(\r\n        (result): result is PromiseRejectedResult => result.status === 'rejected'\r\n      );\r\n      if (rejection != null) {\r\n        throw new MongoCryptCreateDataKeyError(encryptedFields, { cause: rejection.reason });\r\n      }\r\n    }\r\n\r\n    try {\r\n      const collection = await db.createCollection<TSchema>(name, {\r\n        ...createCollectionOptions,\r\n        encryptedFields\r\n      });\r\n      return { collection, encryptedFields };\r\n    } catch (cause) {\r\n      throw new MongoCryptCreateEncryptedCollectionError(encryptedFields, { cause });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\r\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\r\n   *\r\n   * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON\r\n   * @param options -\r\n   * @returns a Promise that either resolves with the encrypted value, or rejects with an error.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Encryption with async/await api\r\n   * async function encryptMyData(value) {\r\n   *   const keyId = await clientEncryption.createDataKey('local');\r\n   *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Encryption using a keyAltName\r\n   * async function encryptMyData(value) {\r\n   *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\r\n   *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\r\n   * }\r\n   * ```\r\n   */\r\n  async encrypt(value: unknown, options: ClientEncryptionEncryptOptions): Promise<Binary> {\r\n    return this._encrypt(value, false, options);\r\n  }\r\n\r\n  /**\r\n   * Encrypts a Match Expression or Aggregate Expression to query a range index.\r\n   *\r\n   * Only supported when queryType is \"rangePreview\" and algorithm is \"RangePreview\".\r\n   *\r\n   * @experimental The Range algorithm is experimental only. It is not intended for production use. It is subject to breaking changes.\r\n   *\r\n   * @param expression - a BSON document of one of the following forms:\r\n   *  1. A Match Expression of this form:\r\n   *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`\r\n   *  2. An Aggregate Expression of this form:\r\n   *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`\r\n   *\r\n   *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.\r\n   *\r\n   * @param options -\r\n   * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.\r\n   */\r\n  async encryptExpression(\r\n    expression: Document,\r\n    options: ClientEncryptionEncryptOptions\r\n  ): Promise<Binary> {\r\n    return this._encrypt(expression, true, options);\r\n  }\r\n\r\n  /**\r\n   * Explicitly decrypt a provided encrypted value\r\n   *\r\n   * @param value - An encrypted value\r\n   * @returns a Promise that either resolves with the decrypted value, or rejects with an error\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // Decrypting value with async/await API\r\n   * async function decryptMyValue(value) {\r\n   *   return clientEncryption.decrypt(value);\r\n   * }\r\n   * ```\r\n   */\r\n  async decrypt<T = any>(value: Binary): Promise<T> {\r\n    const valueBuffer = serialize({ v: value });\r\n    const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\r\n\r\n    const stateMachine = new StateMachine({\r\n      proxyOptions: this._proxyOptions,\r\n      tlsOptions: this._tlsOptions\r\n    });\r\n\r\n    const { v } = await stateMachine.execute<{ v: T }>(this, context);\r\n\r\n    return v;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * Ask the user for KMS credentials.\r\n   *\r\n   * This returns anything that looks like the kmsProviders original input\r\n   * option. It can be empty, and any provider specified here will override\r\n   * the original ones.\r\n   */\r\n  async askForKMSCredentials(): Promise<KMSProviders> {\r\n    return refreshKMSCredentials(this._kmsProviders);\r\n  }\r\n\r\n  static get libmongocryptVersion() {\r\n    return ClientEncryption.getMongoCrypt().libmongocryptVersion;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * A helper that perform explicit encryption of values and expressions.\r\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\r\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\r\n   *\r\n   * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON\r\n   * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression\r\n   * @param options - options to pass to encrypt\r\n   * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return\r\n   *          value will be a bson document.  When false, the value will be a BSON Binary.\r\n   *\r\n   */\r\n  private async _encrypt(\r\n    value: unknown,\r\n    expressionMode: boolean,\r\n    options: ClientEncryptionEncryptOptions\r\n  ): Promise<Binary> {\r\n    const { algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions } = options;\r\n    const contextOptions: ExplicitEncryptionContextOptions = {\r\n      expressionMode,\r\n      algorithm\r\n    };\r\n    if (keyId) {\r\n      contextOptions.keyId = keyId.buffer;\r\n    }\r\n    if (keyAltName) {\r\n      if (keyId) {\r\n        throw new MongoCryptInvalidArgumentError(\r\n          `\"options\" cannot contain both \"keyId\" and \"keyAltName\"`\r\n        );\r\n      }\r\n      if (typeof keyAltName !== 'string') {\r\n        throw new MongoCryptInvalidArgumentError(\r\n          `\"options.keyAltName\" must be of type string, but was of type ${typeof keyAltName}`\r\n        );\r\n      }\r\n\r\n      contextOptions.keyAltName = serialize({ keyAltName });\r\n    }\r\n    if (typeof contentionFactor === 'number' || typeof contentionFactor === 'bigint') {\r\n      contextOptions.contentionFactor = contentionFactor;\r\n    }\r\n    if (typeof queryType === 'string') {\r\n      contextOptions.queryType = queryType;\r\n    }\r\n\r\n    if (typeof rangeOptions === 'object') {\r\n      contextOptions.rangeOptions = serialize(rangeOptions);\r\n    }\r\n\r\n    const valueBuffer = serialize({ v: value });\r\n    const stateMachine = new StateMachine({\r\n      proxyOptions: this._proxyOptions,\r\n      tlsOptions: this._tlsOptions\r\n    });\r\n    const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\r\n\r\n    const result = await stateMachine.execute<{ v: Binary }>(this, context);\r\n    return result.v;\r\n  }\r\n}\r\n\r\n/**\r\n * @public\r\n * Options to provide when encrypting data.\r\n */\r\nexport interface ClientEncryptionEncryptOptions {\r\n  /**\r\n   * The algorithm to use for encryption.\r\n   */\r\n  algorithm:\r\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'\r\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Random'\r\n    | 'Indexed'\r\n    | 'Unindexed'\r\n    | 'RangePreview';\r\n\r\n  /**\r\n   * The id of the Binary dataKey to use for encryption\r\n   */\r\n  keyId?: Binary;\r\n\r\n  /**\r\n   * A unique string name corresponding to an already existing dataKey.\r\n   */\r\n  keyAltName?: string;\r\n\r\n  /** The contention factor. */\r\n  contentionFactor?: bigint | number;\r\n\r\n  /**\r\n   * The query type supported.  Only the queryType `equality` is stable.\r\n   *\r\n   * @experimental Public Technical Preview: The queryType `rangePreview` is experimental.\r\n   */\r\n  queryType?: 'equality' | 'rangePreview';\r\n\r\n  /** @experimental Public Technical Preview: The index options for a Queryable Encryption field supporting \"rangePreview\" queries.*/\r\n  rangeOptions?: RangeOptions;\r\n}\r\n\r\n/**\r\n * @public\r\n * @experimental\r\n */\r\nexport interface ClientEncryptionRewrapManyDataKeyProviderOptions {\r\n  provider: ClientEncryptionDataKeyProvider;\r\n  masterKey?:\r\n    | AWSEncryptionKeyOptions\r\n    | AzureEncryptionKeyOptions\r\n    | GCPEncryptionKeyOptions\r\n    | undefined;\r\n}\r\n\r\n/**\r\n * @public\r\n * Additional settings to provide when creating a new `ClientEncryption` instance.\r\n */\r\nexport interface ClientEncryptionOptions {\r\n  /**\r\n   * The namespace of the key vault, used to store encryption keys\r\n   */\r\n  keyVaultNamespace: string;\r\n\r\n  /**\r\n   * A MongoClient used to fetch keys from a key vault. Defaults to client.\r\n   */\r\n  keyVaultClient?: MongoClient | undefined;\r\n\r\n  /**\r\n   * Options for specific KMS providers to use\r\n   */\r\n  kmsProviders?: KMSProviders;\r\n\r\n  /**\r\n   * Options for specifying a Socks5 proxy to use for connecting to the KMS.\r\n   */\r\n  proxyOptions?: ProxyOptions;\r\n\r\n  /**\r\n   * TLS options for kms providers to use.\r\n   */\r\n  tlsOptions?: CSFLEKMSTlsOptions;\r\n}\r\n\r\n/**\r\n * @public\r\n * Configuration options for making an AWS encryption key\r\n */\r\nexport interface AWSEncryptionKeyOptions {\r\n  /**\r\n   * The AWS region of the KMS\r\n   */\r\n  region: string;\r\n\r\n  /**\r\n   * The Amazon Resource Name (ARN) to the AWS customer master key (CMK)\r\n   */\r\n  key: string;\r\n\r\n  /**\r\n   * An alternate host to send KMS requests to. May include port number.\r\n   */\r\n  endpoint?: string | undefined;\r\n}\r\n\r\n/**\r\n * @public\r\n * Configuration options for making an AWS encryption key\r\n */\r\nexport interface GCPEncryptionKeyOptions {\r\n  /**\r\n   * GCP project ID\r\n   */\r\n  projectId: string;\r\n\r\n  /**\r\n   * Location name (e.g. \"global\")\r\n   */\r\n  location: string;\r\n\r\n  /**\r\n   * Key ring name\r\n   */\r\n  keyRing: string;\r\n\r\n  /**\r\n   * Key name\r\n   */\r\n  keyName: string;\r\n\r\n  /**\r\n   * Key version\r\n   */\r\n  keyVersion?: string | undefined;\r\n\r\n  /**\r\n   * KMS URL, defaults to `https://www.googleapis.com/auth/cloudkms`\r\n   */\r\n  endpoint?: string | undefined;\r\n}\r\n\r\n/**\r\n * @public\r\n * Configuration options for making an Azure encryption key\r\n */\r\nexport interface AzureEncryptionKeyOptions {\r\n  /**\r\n   * Key name\r\n   */\r\n  keyName: string;\r\n\r\n  /**\r\n   * Key vault URL, typically `<name>.vault.azure.net`\r\n   */\r\n  keyVaultEndpoint: string;\r\n\r\n  /**\r\n   * Key version\r\n   */\r\n  keyVersion?: string | undefined;\r\n}\r\n\r\n/**\r\n * @public\r\n * Options to provide when creating a new data key.\r\n */\r\nexport interface ClientEncryptionCreateDataKeyProviderOptions {\r\n  /**\r\n   * Identifies a new KMS-specific key used to encrypt the new data key\r\n   */\r\n  masterKey?:\r\n    | AWSEncryptionKeyOptions\r\n    | AzureEncryptionKeyOptions\r\n    | GCPEncryptionKeyOptions\r\n    | undefined;\r\n\r\n  /**\r\n   * An optional list of string alternate names used to reference a key.\r\n   * If a key is created with alternate names, then encryption may refer to the key by the unique alternate name instead of by _id.\r\n   */\r\n  keyAltNames?: string[] | undefined;\r\n\r\n  /** @experimental */\r\n  keyMaterial?: Buffer | Binary;\r\n}\r\n\r\n/**\r\n * @public\r\n * @experimental\r\n */\r\nexport interface ClientEncryptionRewrapManyDataKeyProviderOptions {\r\n  provider: ClientEncryptionDataKeyProvider;\r\n  masterKey?:\r\n    | AWSEncryptionKeyOptions\r\n    | AzureEncryptionKeyOptions\r\n    | GCPEncryptionKeyOptions\r\n    | undefined;\r\n}\r\n\r\n/**\r\n * @public\r\n * @experimental\r\n */\r\nexport interface ClientEncryptionRewrapManyDataKeyResult {\r\n  /** The result of rewrapping data keys. If unset, no keys matched the filter. */\r\n  bulkWriteResult?: BulkWriteResult;\r\n}\r\n\r\n/**\r\n * @public\r\n * RangeOptions specifies index options for a Queryable Encryption field supporting \"rangePreview\" queries.\r\n * min, max, sparsity, and range must match the values set in the encryptedFields of the destination collection.\r\n * For double and decimal128, min/max/precision must all be set, or all be unset.\r\n */\r\nexport interface RangeOptions {\r\n  min?: any;\r\n  max?: any;\r\n  sparsity: Long;\r\n  precision?: number;\r\n}\r\n\r\n/**\r\n * @public\r\n * Options to provide when encrypting data.\r\n */\r\nexport interface ClientEncryptionEncryptOptions {\r\n  /**\r\n   * The algorithm to use for encryption.\r\n   */\r\n  algorithm:\r\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'\r\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Random'\r\n    | 'Indexed'\r\n    | 'Unindexed'\r\n    | 'RangePreview';\r\n\r\n  /**\r\n   * The id of the Binary dataKey to use for encryption\r\n   */\r\n  keyId?: Binary;\r\n\r\n  /**\r\n   * A unique string name corresponding to an already existing dataKey.\r\n   */\r\n  keyAltName?: string;\r\n\r\n  /** The contention factor. */\r\n  contentionFactor?: bigint | number;\r\n\r\n  /**\r\n   * The query type supported.  Only the queryType `equality` is stable.\r\n   *\r\n   * @experimental Public Technical Preview: The queryType `rangePreview` is experimental.\r\n   */\r\n  queryType?: 'equality' | 'rangePreview';\r\n\r\n  /** @experimental Public Technical Preview: The index options for a Queryable Encryption field supporting \"rangePreview\" queries.*/\r\n  rangeOptions?: RangeOptions;\r\n}\r\n"],"mappings":";;;;;;AAOA,MAAAA,MAAA,GAAAC,OAAA;AAMA,MAAAC,MAAA,GAAAD,OAAA;AAKA,MAAAE,OAAA,GAAAF,OAAA;AACA,MAAAG,eAAA,GAAAH,OAAA;AACA,MAAAI,QAAA,GAAAJ,OAAA;AAKA,MAAAK,OAAA,GAAAL,OAAA;AAKA,MAAAM,eAAA,GAAAN,OAAA;AAiBA;;;;AAIA,MAAaO,gBAAgB;EAiB3B;EACA,OAAOC,aAAaA,CAAA;IAClB,MAAMC,UAAU,GAAG,IAAAR,MAAA,CAAAS,0BAA0B,GAAE;IAC/C,IAAI,cAAc,IAAID,UAAU,EAAE;MAChC,MAAMA,UAAU,CAACE,YAAY;;IAE/B,OAAOF,UAAU,CAACG,UAAU;EAC9B;EAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BAC,YAAYC,MAAmB,EAAEC,OAAgC;IAC/D,IAAI,CAACC,OAAO,GAAGF,MAAM;IACrB,IAAI,CAACG,aAAa,GAAGF,OAAO,CAACG,YAAY,IAAI,EAAE;IAC/C,IAAI,CAACC,WAAW,GAAGJ,OAAO,CAACK,UAAU,IAAI,EAAE;IAC3C,IAAI,CAACC,aAAa,GAAGN,OAAO,CAACO,YAAY,IAAI,EAAE;IAE/C,IAAIP,OAAO,CAACQ,iBAAiB,IAAI,IAAI,EAAE;MACrC,MAAM,IAAInB,QAAA,CAAAoB,8BAA8B,CAAC,6CAA6C,CAAC;;IAGzF,MAAMC,iBAAiB,GAAsB;MAC3C,GAAGV,OAAO;MACVZ,eAAe;MACfmB,YAAY,EAAE,CAACI,MAAM,CAACC,QAAQ,CAAC,IAAI,CAACN,aAAa,CAAC,GAC7C,IAAAtB,MAAA,CAAA6B,SAAS,EAAC,IAAI,CAACP,aAAa,CAAY,GACzC,IAAI,CAACA;KACV;IAED,IAAI,CAACQ,kBAAkB,GAAGd,OAAO,CAACQ,iBAAiB;IACnD,IAAI,CAACO,eAAe,GAAGf,OAAO,CAACgB,cAAc,IAAIjB,MAAM;IACvD,MAAMF,UAAU,GAAGL,gBAAgB,CAACC,aAAa,EAAE;IACnD,IAAI,CAACwB,WAAW,GAAG,IAAIpB,UAAU,CAACa,iBAAiB,CAAC;EACtD;EAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgCA,MAAMQ,aAAaA,CACjBC,QAAyC,EACzCnB,OAAA,GAAwD,EAAE;IAE1D,IAAIA,OAAO,CAACoB,WAAW,IAAI,CAACC,KAAK,CAACC,OAAO,CAACtB,OAAO,CAACoB,WAAW,CAAC,EAAE;MAC9D,MAAM,IAAI/B,QAAA,CAAAoB,8BAA8B,CACtC,qEAAqE,OAAOT,OAAO,CAACoB,WAAW,GAAG,CACnG;;IAGH,IAAIA,WAAW,GAAGG,SAAS;IAC3B,IAAIvB,OAAO,CAACoB,WAAW,IAAIpB,OAAO,CAACoB,WAAW,CAACI,MAAM,GAAG,CAAC,EAAE;MACzDJ,WAAW,GAAGpB,OAAO,CAACoB,WAAW,CAACK,GAAG,CAAC,CAACC,UAAU,EAAEC,CAAC,KAAI;QACtD,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE;UAClC,MAAM,IAAIrC,QAAA,CAAAoB,8BAA8B,CACtC,uEAAuEkB,CAAC,gBAAgB,OAAOD,UAAU,EAAE,CAC5G;;QAGH,OAAO,IAAA1C,MAAA,CAAA6B,SAAS,EAAC;UAAEa;QAAU,CAAE,CAAC;MAClC,CAAC,CAAC;;IAGJ,IAAIE,WAAW,GAAGL,SAAS;IAC3B,IAAIvB,OAAO,CAAC4B,WAAW,EAAE;MACvBA,WAAW,GAAG,IAAA5C,MAAA,CAAA6B,SAAS,EAAC;QAAEe,WAAW,EAAE5B,OAAO,CAAC4B;MAAW,CAAE,CAAC;;IAG/D,MAAMC,WAAW,GAAG,IAAA7C,MAAA,CAAA6B,SAAS,EAAC;MAC5BM,QAAQ;MACR,GAAGnB,OAAO,CAAC8B;KACZ,CAAC;IAEF,MAAMC,OAAO,GAAG,IAAI,CAACd,WAAW,CAACe,kBAAkB,CAACH,WAAW,EAAE;MAC/DT,WAAW;MACXQ;KACD,CAAC;IAEF,MAAMK,YAAY,GAAG,IAAI1C,eAAA,CAAA2C,YAAY,CAAC;MACpC/B,YAAY,EAAE,IAAI,CAACD,aAAa;MAChCG,UAAU,EAAE,IAAI,CAACD;KAClB,CAAC;IAEF,MAAM+B,OAAO,GAAG,MAAMF,YAAY,CAACG,OAAO,CAAU,IAAI,EAAEL,OAAO,CAAC;IAElE,MAAM;MAAEM,EAAE,EAAEC,MAAM;MAAEC,UAAU,EAAEC;IAAc,CAAE,GAAGrD,OAAA,CAAAsD,0BAA0B,CAACC,UAAU,CACtF,IAAI,CAAC5B,kBAAkB,CACxB;IAED,MAAM;MAAE6B;IAAU,CAAE,GAAG,MAAM,IAAI,CAAC5B,eAAe,CAC9CsB,EAAE,CAACC,MAAM,CAAC,CACVC,UAAU,CAAUC,cAAc,CAAC,CACnCI,SAAS,CAACT,OAAO,EAAE;MAAEU,YAAY,EAAE;QAAEC,CAAC,EAAE;MAAU;IAAE,CAAE,CAAC;IAE1D,OAAOH,UAAU;EACnB;EAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2BA,MAAMI,iBAAiBA,CACrBC,MAAuB,EACvBhD,OAAyD;IAEzD,IAAIiD,oBAAoB,GAAG1B,SAAS;IACpC,IAAIvB,OAAO,EAAE;MACX,MAAMkD,gBAAgB,GAAGC,MAAM,CAACC,MAAM,CAAC;QAAEjC,QAAQ,EAAEnB,OAAO,CAACmB;MAAQ,CAAE,EAAEnB,OAAO,CAAC8B,SAAS,CAAC;MACzFmB,oBAAoB,GAAG,IAAAjE,MAAA,CAAA6B,SAAS,EAACqC,gBAAgB,CAAC;;IAEpD,MAAMG,UAAU,GAAG,IAAArE,MAAA,CAAA6B,SAAS,EAACmC,MAAM,CAAC;IACpC,MAAMjB,OAAO,GAAG,IAAI,CAACd,WAAW,CAACqC,4BAA4B,CAACD,UAAU,EAAEJ,oBAAoB,CAAC;IAC/F,MAAMhB,YAAY,GAAG,IAAI1C,eAAA,CAAA2C,YAAY,CAAC;MACpC/B,YAAY,EAAE,IAAI,CAACD,aAAa;MAChCG,UAAU,EAAE,IAAI,CAACD;KAClB,CAAC;IAEF,MAAM;MAAEmD,CAAC,EAAEC;IAAQ,CAAE,GAAG,MAAMvB,YAAY,CAACG,OAAO,CAAmB,IAAI,EAAEL,OAAO,CAAC;IACnF,IAAIyB,QAAQ,CAAChC,MAAM,KAAK,CAAC,EAAE;MACzB,OAAO,EAAE;;IAGX,MAAM;MAAEa,EAAE,EAAEC,MAAM;MAAEC,UAAU,EAAEC;IAAc,CAAE,GAAGrD,OAAA,CAAAsD,0BAA0B,CAACC,UAAU,CACtF,IAAI,CAAC5B,kBAAkB,CACxB;IAED,MAAM2C,YAAY,GAAGD,QAAQ,CAAC/B,GAAG,CAC9BiC,GAAY,KAAsC;MACjDC,SAAS,EAAE;QACTX,MAAM,EAAE;UAAEY,GAAG,EAAEF,GAAG,CAACE;QAAG,CAAE;QACxBC,MAAM,EAAE;UACNC,IAAI,EAAE;YACJhC,SAAS,EAAE4B,GAAG,CAAC5B,SAAS;YACxBF,WAAW,EAAE8B,GAAG,CAAC9B;WAClB;UACDmC,YAAY,EAAE;YACZC,UAAU,EAAE;;;;KAInB,CAAC,CACH;IAED,MAAMC,MAAM,GAAG,MAAM,IAAI,CAAClD,eAAe,CACtCsB,EAAE,CAACC,MAAM,CAAC,CACVC,UAAU,CAAUC,cAAc,CAAC,CACnC0B,SAAS,CAACT,YAAY,EAAE;MACvBZ,YAAY,EAAE;QAAEC,CAAC,EAAE;MAAU;KAC9B,CAAC;IAEJ,OAAO;MAAEqB,eAAe,EAAEF;IAAM,CAAE;EACpC;EAEA;;;;;;;;;;;;;;;EAeA,MAAMG,SAASA,CAACR,GAAW;IACzB,MAAM;MAAEvB,EAAE,EAAEC,MAAM;MAAEC,UAAU,EAAEC;IAAc,CAAE,GAAGrD,OAAA,CAAAsD,0BAA0B,CAACC,UAAU,CACtF,IAAI,CAAC5B,kBAAkB,CACxB;IAED,OAAO,IAAI,CAACC,eAAe,CACxBsB,EAAE,CAACC,MAAM,CAAC,CACVC,UAAU,CAAUC,cAAc,CAAC,CACnC6B,SAAS,CAAC;MAAET;IAAG,CAAE,EAAE;MAAEf,YAAY,EAAE;QAAEC,CAAC,EAAE;MAAU;IAAE,CAAE,CAAC;EAC5D;EAEA;;;;;;;;;;;;EAYAwB,OAAOA,CAAA;IACL,MAAM;MAAEjC,EAAE,EAAEC,MAAM;MAAEC,UAAU,EAAEC;IAAc,CAAE,GAAGrD,OAAA,CAAAsD,0BAA0B,CAACC,UAAU,CACtF,IAAI,CAAC5B,kBAAkB,CACxB;IAED,OAAO,IAAI,CAACC,eAAe,CACxBsB,EAAE,CAACC,MAAM,CAAC,CACVC,UAAU,CAAUC,cAAc,CAAC,CACnC+B,IAAI,CAAC,EAAE,EAAE;MAAEC,WAAW,EAAE;QAAEC,KAAK,EAAE;MAAU;IAAE,CAAE,CAAC;EACrD;EAEA;;;;;;;;;;;;;;;EAeA,MAAMC,MAAMA,CAACd,GAAW;IACtB,MAAM;MAAEvB,EAAE,EAAEC,MAAM;MAAEC,UAAU,EAAEC;IAAc,CAAE,GAAGrD,OAAA,CAAAsD,0BAA0B,CAACC,UAAU,CACtF,IAAI,CAAC5B,kBAAkB,CACxB;IAED,OAAO,IAAI,CAACC,eAAe,CACxBsB,EAAE,CAACC,MAAM,CAAC,CACVC,UAAU,CAAUC,cAAc,CAAC,CACnCmC,OAAO,CAAC;MAAEf;IAAG,CAAE,EAAE;MAAEY,WAAW,EAAE;QAAEC,KAAK,EAAE;MAAU;IAAE,CAAE,CAAC;EAC7D;EAEA;;;;;;;;;;;;;;;;EAgBA,MAAMG,eAAeA,CAAClD,UAAkB;IACtC,MAAM;MAAEW,EAAE,EAAEC,MAAM;MAAEC,UAAU,EAAEC;IAAc,CAAE,GAAGrD,OAAA,CAAAsD,0BAA0B,CAACC,UAAU,CACtF,IAAI,CAAC5B,kBAAkB,CACxB;IAED,OAAO,IAAI,CAACC,eAAe,CACxBsB,EAAE,CAACC,MAAM,CAAC,CACVC,UAAU,CAAUC,cAAc,CAAC,CACnCmC,OAAO,CAAC;MAAEvD,WAAW,EAAEM;IAAU,CAAE,EAAE;MAAE8C,WAAW,EAAE;QAAEC,KAAK,EAAE;MAAU;IAAE,CAAE,CAAC;EACjF;EAEA;;;;;;;;;;;;;;;;;;;;EAoBA,MAAMI,aAAaA,CAACjB,GAAW,EAAElC,UAAkB;IACjD,MAAM;MAAEW,EAAE,EAAEC,MAAM;MAAEC,UAAU,EAAEC;IAAc,CAAE,GAAGrD,OAAA,CAAAsD,0BAA0B,CAACC,UAAU,CACtF,IAAI,CAAC5B,kBAAkB,CACxB;IAED,MAAMgE,KAAK,GAAG,MAAM,IAAI,CAAC/D,eAAe,CACrCsB,EAAE,CAACC,MAAM,CAAC,CACVC,UAAU,CAAUC,cAAc,CAAC,CACnCuC,gBAAgB,CACf;MAAEnB;IAAG,CAAE,EACP;MAAEoB,SAAS,EAAE;QAAE5D,WAAW,EAAEM;MAAU;IAAE,CAAE,EAC1C;MAAEmB,YAAY,EAAE;QAAEC,CAAC,EAAE;MAAU,CAAE;MAAEmC,cAAc,EAAE;IAAQ,CAAE,CAC9D;IAEH,OAAOH,KAAK;EACd;EAEA;;;;;;;;;;;;;;;;;;;;;;;EAuBA,MAAMI,gBAAgBA,CAACtB,GAAW,EAAElC,UAAkB;IACpD,MAAM;MAAEW,EAAE,EAAEC,MAAM;MAAEC,UAAU,EAAEC;IAAc,CAAE,GAAGrD,OAAA,CAAAsD,0BAA0B,CAACC,UAAU,CACtF,IAAI,CAAC5B,kBAAkB,CACxB;IAED,MAAMqE,QAAQ,GAAG,CACf;MACErB,IAAI,EAAE;QACJ1C,WAAW,EAAE;UACXgE,KAAK,EAAE,CACL;YACEC,GAAG,EAAE,CAAC,cAAc,EAAE,CAAC3D,UAAU,CAAC;WACnC,EACD,UAAU,EACV;YACE4D,OAAO,EAAE;cACPC,KAAK,EAAE,cAAc;cACrBC,IAAI,EAAE;gBACJC,GAAG,EAAE,CAAC,QAAQ,EAAE/D,UAAU;;;WAG/B;;;KAIR,CACF;IACD,MAAMoD,KAAK,GAAG,MAAM,IAAI,CAAC/D,eAAe,CACrCsB,EAAE,CAACC,MAAM,CAAC,CACVC,UAAU,CAAUC,cAAc,CAAC,CACnCuC,gBAAgB,CAAC;MAAEnB;IAAG,CAAE,EAAEuB,QAAQ,EAAE;MACnCtC,YAAY,EAAE;QAAEC,CAAC,EAAE;MAAU,CAAE;MAC/BmC,cAAc,EAAE;KACjB,CAAC;IAEJ,OAAOH,KAAK;EACd;EAEA;;;;;;;;;;;;EAYA,MAAMY,yBAAyBA,CAC7BrD,EAAM,EACNsD,IAAY,EACZ3F,OAMC;IAED,MAAM;MACJmB,QAAQ;MACRW,SAAS;MACT8D,uBAAuB,EAAE;QACvBC,eAAe,EAAE;UAAE,GAAGA;QAAe,CAAE;QACvC,GAAGD;MAAuB;IAC3B,CACF,GAAG5F,OAAO;IAEX,IAAIqB,KAAK,CAACC,OAAO,CAACuE,eAAe,CAACC,MAAM,CAAC,EAAE;MACzC,MAAMC,qBAAqB,GAAGF,eAAe,CAACC,MAAM,CAACrE,GAAG,CAAC,MAAMuE,KAAK,IAClEA,KAAK,IAAI,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAACC,KAAK,IAAI,IAAI,GAC7DD,KAAK,GACL;QACE,GAAGA,KAAK;QACRC,KAAK,EAAE,MAAM,IAAI,CAAC/E,aAAa,CAACC,QAAQ,EAAE;UAAEW;QAAS,CAAE;OACxD,CACN;MAED,MAAMoE,wBAAwB,GAAG,MAAMC,OAAO,CAACC,UAAU,CAACL,qBAAqB,CAAC;MAEhFF,eAAe,CAACC,MAAM,GAAGI,wBAAwB,CAACzE,GAAG,CAAC,CAAC4E,UAAU,EAAEC,KAAK,KACtED,UAAU,CAACE,MAAM,KAAK,WAAW,GAAGF,UAAU,CAACvB,KAAK,GAAGe,eAAe,CAACC,MAAM,CAACQ,KAAK,CAAC,CACrF;MAED,MAAME,SAAS,GAAGN,wBAAwB,CAAC3B,IAAI,CAC5CN,MAAM,IAAsCA,MAAM,CAACsC,MAAM,KAAK,UAAU,CAC1E;MACD,IAAIC,SAAS,IAAI,IAAI,EAAE;QACrB,MAAM,IAAInH,QAAA,CAAAoH,4BAA4B,CAACZ,eAAe,EAAE;UAAEa,KAAK,EAAEF,SAAS,CAACG;QAAM,CAAE,CAAC;;;IAIxF,IAAI;MACF,MAAMpE,UAAU,GAAG,MAAMF,EAAE,CAACuE,gBAAgB,CAAUjB,IAAI,EAAE;QAC1D,GAAGC,uBAAuB;QAC1BC;OACD,CAAC;MACF,OAAO;QAAEtD,UAAU;QAAEsD;MAAe,CAAE;KACvC,CAAC,OAAOa,KAAK,EAAE;MACd,MAAM,IAAIrH,QAAA,CAAAwH,wCAAwC,CAAChB,eAAe,EAAE;QAAEa;MAAK,CAAE,CAAC;;EAElF;EAEA;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BA,MAAMI,OAAOA,CAAChC,KAAc,EAAE9E,OAAuC;IACnE,OAAO,IAAI,CAAC+G,QAAQ,CAACjC,KAAK,EAAE,KAAK,EAAE9E,OAAO,CAAC;EAC7C;EAEA;;;;;;;;;;;;;;;;;;EAkBA,MAAMgH,iBAAiBA,CACrBC,UAAoB,EACpBjH,OAAuC;IAEvC,OAAO,IAAI,CAAC+G,QAAQ,CAACE,UAAU,EAAE,IAAI,EAAEjH,OAAO,CAAC;EACjD;EAEA;;;;;;;;;;;;;;EAcA,MAAMkH,OAAOA,CAAUpC,KAAa;IAClC,MAAMqC,WAAW,GAAG,IAAAnI,MAAA,CAAA6B,SAAS,EAAC;MAAE0C,CAAC,EAAEuB;IAAK,CAAE,CAAC;IAC3C,MAAM/C,OAAO,GAAG,IAAI,CAACd,WAAW,CAACmG,6BAA6B,CAACD,WAAW,CAAC;IAE3E,MAAMlF,YAAY,GAAG,IAAI1C,eAAA,CAAA2C,YAAY,CAAC;MACpC/B,YAAY,EAAE,IAAI,CAACD,aAAa;MAChCG,UAAU,EAAE,IAAI,CAACD;KAClB,CAAC;IAEF,MAAM;MAAEmD;IAAC,CAAE,GAAG,MAAMtB,YAAY,CAACG,OAAO,CAAW,IAAI,EAAEL,OAAO,CAAC;IAEjE,OAAOwB,CAAC;EACV;EAEA;;;;;;;;EAQA,MAAM8D,oBAAoBA,CAAA;IACxB,OAAO,IAAA/H,OAAA,CAAAgI,qBAAqB,EAAC,IAAI,CAAChH,aAAa,CAAC;EAClD;EAEA,WAAWiH,oBAAoBA,CAAA;IAC7B,OAAO/H,gBAAgB,CAACC,aAAa,EAAE,CAAC8H,oBAAoB;EAC9D;EAEA;;;;;;;;;;;;;EAaQ,MAAMR,QAAQA,CACpBjC,KAAc,EACd0C,cAAuB,EACvBxH,OAAuC;IAEvC,MAAM;MAAEyH,SAAS;MAAExB,KAAK;MAAEvE,UAAU;MAAEgG,gBAAgB;MAAEC,SAAS;MAAEC;IAAY,CAAE,GAAG5H,OAAO;IAC3F,MAAM6H,cAAc,GAAqC;MACvDL,cAAc;MACdC;KACD;IACD,IAAIxB,KAAK,EAAE;MACT4B,cAAc,CAAC5B,KAAK,GAAGA,KAAK,CAAC6B,MAAM;;IAErC,IAAIpG,UAAU,EAAE;MACd,IAAIuE,KAAK,EAAE;QACT,MAAM,IAAI5G,QAAA,CAAAoB,8BAA8B,CACtC,wDAAwD,CACzD;;MAEH,IAAI,OAAOiB,UAAU,KAAK,QAAQ,EAAE;QAClC,MAAM,IAAIrC,QAAA,CAAAoB,8BAA8B,CACtC,gEAAgE,OAAOiB,UAAU,EAAE,CACpF;;MAGHmG,cAAc,CAACnG,UAAU,GAAG,IAAA1C,MAAA,CAAA6B,SAAS,EAAC;QAAEa;MAAU,CAAE,CAAC;;IAEvD,IAAI,OAAOgG,gBAAgB,KAAK,QAAQ,IAAI,OAAOA,gBAAgB,KAAK,QAAQ,EAAE;MAChFG,cAAc,CAACH,gBAAgB,GAAGA,gBAAgB;;IAEpD,IAAI,OAAOC,SAAS,KAAK,QAAQ,EAAE;MACjCE,cAAc,CAACF,SAAS,GAAGA,SAAS;;IAGtC,IAAI,OAAOC,YAAY,KAAK,QAAQ,EAAE;MACpCC,cAAc,CAACD,YAAY,GAAG,IAAA5I,MAAA,CAAA6B,SAAS,EAAC+G,YAAY,CAAC;;IAGvD,MAAMT,WAAW,GAAG,IAAAnI,MAAA,CAAA6B,SAAS,EAAC;MAAE0C,CAAC,EAAEuB;IAAK,CAAE,CAAC;IAC3C,MAAM7C,YAAY,GAAG,IAAI1C,eAAA,CAAA2C,YAAY,CAAC;MACpC/B,YAAY,EAAE,IAAI,CAACD,aAAa;MAChCG,UAAU,EAAE,IAAI,CAACD;KAClB,CAAC;IACF,MAAM2B,OAAO,GAAG,IAAI,CAACd,WAAW,CAAC8G,6BAA6B,CAACZ,WAAW,EAAEU,cAAc,CAAC;IAE3F,MAAM5D,MAAM,GAAG,MAAMhC,YAAY,CAACG,OAAO,CAAgB,IAAI,EAAEL,OAAO,CAAC;IACvE,OAAOkC,MAAM,CAACV,CAAC;EACjB;;AAhqBFyE,OAAA,CAAAxI,gBAAA,GAAAA,gBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}