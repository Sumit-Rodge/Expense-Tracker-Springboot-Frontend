{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst write_concern_1 = require(\"../write_concern\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nexports.DB_AGGREGATE_COLLECTION = 1;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;\n/** @internal */\nclass AggregateOperation extends command_1.CommandOperation {\n  constructor(ns, pipeline, options) {\n    super(undefined, {\n      ...options,\n      dbName: ns.db\n    });\n    this.options = {\n      ...options\n    };\n    // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n    this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;\n    this.pipeline = pipeline;\n    // determine if we have a write stage, override read preference if so\n    this.hasWriteStage = false;\n    if (typeof options?.out === 'string') {\n      this.pipeline = this.pipeline.concat({\n        $out: options.out\n      });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n    if (this.hasWriteStage) {\n      this.trySecondaryWrite = true;\n    } else {\n      delete this.options.writeConcern;\n    }\n    if (this.explain && this.writeConcern) {\n      throw new error_1.MongoInvalidArgumentError('Option \"explain\" cannot be used on an aggregate call with writeConcern');\n    }\n    if (options?.cursor != null && typeof options.cursor !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');\n    }\n  }\n  get commandName() {\n    return 'aggregate';\n  }\n  get canRetryRead() {\n    return !this.hasWriteStage;\n  }\n  addToPipeline(stage) {\n    this.pipeline.push(stage);\n  }\n  async execute(server, session) {\n    const options = this.options;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const command = {\n      aggregate: this.target,\n      pipeline: this.pipeline\n    };\n    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n      this.readConcern = undefined;\n    }\n    if (this.hasWriteStage && this.writeConcern) {\n      write_concern_1.WriteConcern.apply(command, this.writeConcern);\n    }\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n    if (options.let) {\n      command.let = options.let;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n    command.cursor = options.cursor || {};\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n    return super.executeCommand(server, session, command);\n  }\n}\nexports.AggregateOperation = AggregateOperation;\n(0, operation_1.defineAspects)(AggregateOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);","map":{"version":3,"names":["error_1","require","utils_1","write_concern_1","command_1","operation_1","exports","DB_AGGREGATE_COLLECTION","MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT","AggregateOperation","CommandOperation","constructor","ns","pipeline","options","undefined","dbName","db","target","collection","hasWriteStage","out","concat","$out","length","finalStage","$merge","trySecondaryWrite","writeConcern","explain","MongoInvalidArgumentError","cursor","commandName","canRetryRead","addToPipeline","stage","push","execute","server","session","serverWireVersion","maxWireVersion","command","aggregate","readConcern","WriteConcern","apply","bypassDocumentValidation","allowDiskUse","hint","let","comment","batchSize","executeCommand","defineAspects","Aspect","READ_OPERATION","RETRYABLE","EXPLAINABLE","CURSOR_CREATING"],"sources":["C:\\Users\\sumit\\Desktop\\Final project\\Expense-Tracker-Springboot-Frontend\\node_modules\\mongodb\\src\\operations\\aggregate.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport { MongoInvalidArgumentError } from '../error';\r\nimport { type TODO_NODE_3286 } from '../mongo_types';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport { maxWireVersion, type MongoDBNamespace } from '../utils';\r\nimport { WriteConcern } from '../write_concern';\r\nimport { type CollationOptions, CommandOperation, type CommandOperationOptions } from './command';\r\nimport { Aspect, defineAspects, type Hint } from './operation';\r\n\r\n/** @internal */\r\nexport const DB_AGGREGATE_COLLECTION = 1 as const;\r\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8 as const;\r\n\r\n/** @public */\r\nexport interface AggregateOptions extends CommandOperationOptions {\r\n  /** allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \\>). */\r\n  allowDiskUse?: boolean;\r\n  /** The number of documents to return per batch. See [aggregation documentation](https://www.mongodb.com/docs/manual/reference/command/aggregate). */\r\n  batchSize?: number;\r\n  /** Allow driver to bypass schema validation. */\r\n  bypassDocumentValidation?: boolean;\r\n  /** Return the query as cursor, on 2.6 \\> it returns as a real cursor on pre 2.6 it returns as an emulated cursor. */\r\n  cursor?: Document;\r\n  /** specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point. */\r\n  maxTimeMS?: number;\r\n  /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. */\r\n  maxAwaitTimeMS?: number;\r\n  /** Specify collation. */\r\n  collation?: CollationOptions;\r\n  /** Add an index selection hint to an aggregation command */\r\n  hint?: Hint;\r\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\r\n  let?: Document;\r\n\r\n  out?: string;\r\n}\r\n\r\n/** @internal */\r\nexport class AggregateOperation<T = Document> extends CommandOperation<T> {\r\n  override options: AggregateOptions;\r\n  target: string | typeof DB_AGGREGATE_COLLECTION;\r\n  pipeline: Document[];\r\n  hasWriteStage: boolean;\r\n\r\n  constructor(ns: MongoDBNamespace, pipeline: Document[], options?: AggregateOptions) {\r\n    super(undefined, { ...options, dbName: ns.db });\r\n\r\n    this.options = { ...options };\r\n\r\n    // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\r\n    this.target = ns.collection || DB_AGGREGATE_COLLECTION;\r\n\r\n    this.pipeline = pipeline;\r\n\r\n    // determine if we have a write stage, override read preference if so\r\n    this.hasWriteStage = false;\r\n    if (typeof options?.out === 'string') {\r\n      this.pipeline = this.pipeline.concat({ $out: options.out });\r\n      this.hasWriteStage = true;\r\n    } else if (pipeline.length > 0) {\r\n      const finalStage = pipeline[pipeline.length - 1];\r\n      if (finalStage.$out || finalStage.$merge) {\r\n        this.hasWriteStage = true;\r\n      }\r\n    }\r\n\r\n    if (this.hasWriteStage) {\r\n      this.trySecondaryWrite = true;\r\n    } else {\r\n      delete this.options.writeConcern;\r\n    }\r\n\r\n    if (this.explain && this.writeConcern) {\r\n      throw new MongoInvalidArgumentError(\r\n        'Option \"explain\" cannot be used on an aggregate call with writeConcern'\r\n      );\r\n    }\r\n\r\n    if (options?.cursor != null && typeof options.cursor !== 'object') {\r\n      throw new MongoInvalidArgumentError('Cursor options must be an object');\r\n    }\r\n  }\r\n\r\n  override get commandName() {\r\n    return 'aggregate' as const;\r\n  }\r\n\r\n  override get canRetryRead(): boolean {\r\n    return !this.hasWriteStage;\r\n  }\r\n\r\n  addToPipeline(stage: Document): void {\r\n    this.pipeline.push(stage);\r\n  }\r\n\r\n  override async execute(server: Server, session: ClientSession | undefined): Promise<T> {\r\n    const options: AggregateOptions = this.options;\r\n    const serverWireVersion = maxWireVersion(server);\r\n    const command: Document = { aggregate: this.target, pipeline: this.pipeline };\r\n\r\n    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\r\n      this.readConcern = undefined;\r\n    }\r\n\r\n    if (this.hasWriteStage && this.writeConcern) {\r\n      WriteConcern.apply(command, this.writeConcern);\r\n    }\r\n\r\n    if (options.bypassDocumentValidation === true) {\r\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\r\n    }\r\n\r\n    if (typeof options.allowDiskUse === 'boolean') {\r\n      command.allowDiskUse = options.allowDiskUse;\r\n    }\r\n\r\n    if (options.hint) {\r\n      command.hint = options.hint;\r\n    }\r\n\r\n    if (options.let) {\r\n      command.let = options.let;\r\n    }\r\n\r\n    // we check for undefined specifically here to allow falsy values\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    if (options.comment !== undefined) {\r\n      command.comment = options.comment;\r\n    }\r\n\r\n    command.cursor = options.cursor || {};\r\n    if (options.batchSize && !this.hasWriteStage) {\r\n      command.cursor.batchSize = options.batchSize;\r\n    }\r\n\r\n    return super.executeCommand(server, session, command) as TODO_NODE_3286;\r\n  }\r\n}\r\n\r\ndefineAspects(AggregateOperation, [\r\n  Aspect.READ_OPERATION,\r\n  Aspect.RETRYABLE,\r\n  Aspect.EXPLAINABLE,\r\n  Aspect.CURSOR_CREATING\r\n]);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}