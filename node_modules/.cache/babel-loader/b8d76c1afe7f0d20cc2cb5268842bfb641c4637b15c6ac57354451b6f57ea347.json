{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MonitorInterval = exports.RTTPinger = exports.Monitor = exports.ServerMonitoringMode = void 0;\nconst timers_1 = require(\"timers\");\nconst bson_1 = require(\"../bson\");\nconst connect_1 = require(\"../cmap/connect\");\nconst client_metadata_1 = require(\"../cmap/handshake/client_metadata\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_logger_1 = require(\"../mongo_logger\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nconst events_1 = require(\"./events\");\nconst server_1 = require(\"./server\");\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = (0, utils_1.makeStateMachine)({\n  [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],\n  [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor) {\n  return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;\n}\n/** @public */\nexports.ServerMonitoringMode = Object.freeze({\n  auto: 'auto',\n  poll: 'poll',\n  stream: 'stream'\n});\n/** @internal */\nclass Monitor extends mongo_types_1.TypedEventEmitter {\n  constructor(server, options) {\n    super();\n    /** @internal */\n    this.component = mongo_logger_1.MongoLoggableComponent.TOPOLOGY;\n    this[kServer] = server;\n    this.connection = null;\n    this[kCancellationToken] = new mongo_types_1.CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = undefined;\n    this.s = {\n      state: common_1.STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: options.connectTimeoutMS ?? 10000,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,\n      serverMonitoringMode: options.serverMonitoringMode\n    });\n    this.isRunningInFaasEnv = (0, client_metadata_1.getFAASEnv)() != null;\n    this.mongoLogger = this[kServer].topology.client?.mongoLogger;\n    const cancellationToken = this[kCancellationToken];\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = {\n      id: '<monitor>',\n      generation: server.pool.generation,\n      cancellationToken,\n      hostAddress: server.description.hostAddress,\n      ...options,\n      // force BSON serialization options\n      raw: false,\n      useBigInt64: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    };\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n  connect() {\n    if (this.s.state !== common_1.STATE_CLOSED) {\n      return;\n    }\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n    this[kMonitorId]?.wake();\n  }\n  reset() {\n    const topologyVersion = this[kServer].description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this);\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\n    });\n  }\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this);\n    // close monitor\n    this.emit('close');\n    stateTransition(this, common_1.STATE_CLOSED);\n  }\n}\nexports.Monitor = Monitor;\nfunction resetMonitorState(monitor) {\n  monitor[kMonitorId]?.stop();\n  monitor[kMonitorId] = undefined;\n  monitor.rttPinger?.close();\n  monitor.rttPinger = undefined;\n  monitor[kCancellationToken].emit('cancel');\n  monitor.connection?.destroy({\n    force: true\n  });\n  monitor.connection = null;\n}\nfunction useStreamingProtocol(monitor, topologyVersion) {\n  // If we have no topology version we always poll no matter\n  // what the user provided, since the server does not support\n  // the streaming protocol.\n  if (topologyVersion == null) return false;\n  const serverMonitoringMode = monitor.options.serverMonitoringMode;\n  if (serverMonitoringMode === exports.ServerMonitoringMode.poll) return false;\n  if (serverMonitoringMode === exports.ServerMonitoringMode.stream) return true;\n  // If we are in auto mode, we need to figure out if we're in a FaaS\n  // environment or not and choose the appropriate mode.\n  if (monitor.isRunningInFaasEnv) return false;\n  return true;\n}\nfunction checkServer(monitor, callback) {\n  let start;\n  let awaited;\n  const topologyVersion = monitor[kServer].description.topologyVersion;\n  const isAwaitable = useStreamingProtocol(monitor, topologyVersion);\n  monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));\n  function onHeartbeatFailed(err) {\n    monitor.connection?.destroy({\n      force: true\n    });\n    monitor.connection = null;\n    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_FAILED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err, awaited));\n    const error = !(err instanceof error_1.MongoError) ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err), {\n      cause: err\n    }) : err;\n    error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);\n    if (error instanceof error_1.MongoNetworkTimeoutError) {\n      error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);\n    }\n    monitor.emit('resetServer', error);\n    callback(err);\n  }\n  function onHeartbeatSucceeded(hello) {\n    if (!('isWritablePrimary' in hello)) {\n      // Provide hello-style response document.\n      hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];\n    }\n    const duration = isAwaitable && monitor.rttPinger ? monitor.rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);\n    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor[kServer].topology.s.id, hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));\n    if (isAwaitable) {\n      // If we are using the streaming protocol then we immediately issue another 'started'\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));\n      // We have not actually sent an outgoing handshake, but when we get the next response we\n      // want the duration to reflect the time since we last heard from the server\n      start = (0, utils_1.now)();\n    } else {\n      monitor.rttPinger?.close();\n      monitor.rttPinger = undefined;\n      callback(undefined, hello);\n    }\n  }\n  const {\n    connection\n  } = monitor;\n  if (connection && !connection.closed) {\n    const {\n      serverApi,\n      helloOk\n    } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const cmd = {\n      [serverApi?.version || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,\n      ...(isAwaitable && topologyVersion ? {\n        maxAwaitTimeMS,\n        topologyVersion: makeTopologyVersion(topologyVersion)\n      } : {})\n    };\n    const options = isAwaitable ? {\n      socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n      exhaustAllowed: true\n    } : {\n      socketTimeoutMS: connectTimeoutMS\n    };\n    if (isAwaitable && monitor.rttPinger == null) {\n      monitor.rttPinger = new RTTPinger(monitor[kCancellationToken], Object.assign({\n        heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS\n      }, monitor.connectOptions));\n    }\n    // Record new start time before sending handshake\n    start = (0, utils_1.now)();\n    if (isAwaitable) {\n      awaited = true;\n      return connection.exhaustCommand((0, utils_1.ns)('admin.$cmd'), cmd, options, (error, hello) => {\n        if (error) return onHeartbeatFailed(error);\n        return onHeartbeatSucceeded(hello);\n      });\n    }\n    awaited = false;\n    connection.command((0, utils_1.ns)('admin.$cmd'), cmd, options).then(onHeartbeatSucceeded, onHeartbeatFailed);\n    return;\n  }\n  // connecting does an implicit `hello`\n  (async () => {\n    const socket = await (0, connect_1.makeSocket)(monitor.connectOptions);\n    const connection = (0, connect_1.makeConnection)(monitor.connectOptions, socket);\n    // The start time is after socket creation but before the handshake\n    start = (0, utils_1.now)();\n    try {\n      await (0, connect_1.performInitialHandshake)(connection, monitor.connectOptions);\n      return connection;\n    } catch (error) {\n      connection.destroy({\n        force: false\n      });\n      throw error;\n    }\n  })().then(connection => {\n    if (isInCloseState(monitor)) {\n      connection.destroy({\n        force: true\n      });\n      return;\n    }\n    monitor.connection = connection;\n    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor[kServer].topology.s.id, connection.hello?.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), connection.hello, useStreamingProtocol(monitor, connection.hello?.topologyVersion)));\n    callback(undefined, connection.hello);\n  }, error => {\n    monitor.connection = null;\n    awaited = false;\n    onHeartbeatFailed(error);\n  });\n}\nfunction monitorServer(monitor) {\n  return callback => {\n    if (monitor.s.state === STATE_MONITORING) {\n      process.nextTick(callback);\n      return;\n    }\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n      callback();\n    }\n    checkServer(monitor, (err, hello) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === common_1.ServerType.Unknown) {\n          return done();\n        }\n      }\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (useStreamingProtocol(monitor, hello?.topologyVersion)) {\n        (0, timers_1.setTimeout)(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId]?.wake();\n          }\n        }, 0);\n      }\n      done();\n    });\n  };\n}\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)\n  };\n}\n/** @internal */\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this.connection = undefined;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n  close() {\n    this.closed = true;\n    (0, timers_1.clearTimeout)(this[kMonitorId]);\n    this.connection?.destroy({\n      force: true\n    });\n    this.connection = undefined;\n  }\n}\nexports.RTTPinger = RTTPinger;\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = (0, utils_1.now)();\n  options.cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n  if (rttPinger.closed) {\n    return;\n  }\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn?.destroy({\n        force: true\n      });\n      return;\n    }\n    if (rttPinger.connection == null) {\n      rttPinger.connection = conn;\n    }\n    rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);\n    rttPinger[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n  }\n  const connection = rttPinger.connection;\n  if (connection == null) {\n    (0, connect_1.connect)(options).then(connection => {\n      measureAndReschedule(connection);\n    }, () => {\n      rttPinger.connection = undefined;\n      rttPinger[kRoundTripTime] = 0;\n    });\n    return;\n  }\n  const commandName = connection.serverApi?.version || connection.helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND;\n  connection.command((0, utils_1.ns)('admin.$cmd'), {\n    [commandName]: 1\n  }, undefined).then(() => measureAndReschedule(), () => {\n    rttPinger.connection?.destroy({\n      force: true\n    });\n    rttPinger.connection = undefined;\n    rttPinger[kRoundTripTime] = 0;\n    return;\n  });\n}\n/**\r\n * @internal\r\n */\nclass MonitorInterval {\n  constructor(fn, options = {}) {\n    this.isExpeditedCallToFnScheduled = false;\n    this.stopped = false;\n    this.isExecutionInProgress = false;\n    this.hasExecutedOnce = false;\n    this._executeAndReschedule = () => {\n      if (this.stopped) return;\n      if (this.timerId) {\n        (0, timers_1.clearTimeout)(this.timerId);\n      }\n      this.isExpeditedCallToFnScheduled = false;\n      this.isExecutionInProgress = true;\n      this.fn(() => {\n        this.lastExecutionEnded = (0, utils_1.now)();\n        this.isExecutionInProgress = false;\n        this._reschedule(this.heartbeatFrequencyMS);\n      });\n    };\n    this.fn = fn;\n    this.lastExecutionEnded = -Infinity;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;\n    this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;\n    if (options.immediate) {\n      this._executeAndReschedule();\n    } else {\n      this._reschedule(undefined);\n    }\n  }\n  wake() {\n    const currentTime = (0, utils_1.now)();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n    // TODO(NODE-4674): Add error handling and logging to the monitor\n    if (timeSinceLastCall < 0) {\n      return this._executeAndReschedule();\n    }\n    if (this.isExecutionInProgress) {\n      return;\n    }\n    // debounce multiple calls to wake within the `minInterval`\n    if (this.isExpeditedCallToFnScheduled) {\n      return;\n    }\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {\n      this.isExpeditedCallToFnScheduled = true;\n      this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);\n      return;\n    }\n    this._executeAndReschedule();\n  }\n  stop() {\n    this.stopped = true;\n    if (this.timerId) {\n      (0, timers_1.clearTimeout)(this.timerId);\n      this.timerId = undefined;\n    }\n    this.lastExecutionEnded = -Infinity;\n    this.isExpeditedCallToFnScheduled = false;\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toJSON() {\n    const currentTime = (0, utils_1.now)();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n    return {\n      timerId: this.timerId != null ? 'set' : 'cleared',\n      lastCallTime: this.lastExecutionEnded,\n      isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,\n      stopped: this.stopped,\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,\n      currentTime,\n      timeSinceLastCall\n    };\n  }\n  _reschedule(ms) {\n    if (this.stopped) return;\n    if (this.timerId) {\n      (0, timers_1.clearTimeout)(this.timerId);\n    }\n    this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\n  }\n}\nexports.MonitorInterval = MonitorInterval;","map":{"version":3,"names":["timers_1","require","bson_1","connect_1","client_metadata_1","constants_1","error_1","mongo_logger_1","mongo_types_1","utils_1","common_1","events_1","server_1","kServer","Symbol","kMonitorId","kCancellationToken","kRoundTripTime","STATE_IDLE","STATE_MONITORING","stateTransition","makeStateMachine","STATE_CLOSING","STATE_CLOSED","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","exports","ServerMonitoringMode","Object","freeze","auto","poll","stream","Monitor","TypedEventEmitter","constructor","server","options","component","MongoLoggableComponent","TOPOLOGY","connection","CancellationToken","setMaxListeners","Infinity","undefined","address","description","connectTimeoutMS","heartbeatFrequencyMS","minHeartbeatFrequencyMS","serverMonitoringMode","isRunningInFaasEnv","getFAASEnv","mongoLogger","topology","client","cancellationToken","connectOptions","id","generation","pool","hostAddress","raw","useBigInt64","promoteLongs","promoteValues","promoteBuffers","credentials","autoEncrypter","connect","MonitorInterval","monitorServer","immediate","requestCheck","has","wake","reset","topologyVersion","resetMonitorState","close","emit","stop","rttPinger","destroy","force","useStreamingProtocol","checkServer","callback","start","awaited","isAwaitable","emitAndLogHeartbeat","Server","SERVER_HEARTBEAT_STARTED","ServerHeartbeatStartedEvent","onHeartbeatFailed","err","SERVER_HEARTBEAT_FAILED","ServerHeartbeatFailedEvent","calculateDurationInMs","error","MongoError","buildErrorMessage","cause","addErrorLabel","MongoErrorLabel","ResetPool","MongoNetworkTimeoutError","InterruptInUseConnections","onHeartbeatSucceeded","hello","isWritablePrimary","LEGACY_HELLO_COMMAND","duration","roundTripTime","SERVER_HEARTBEAT_SUCCEEDED","connectionId","ServerHeartbeatSucceededEvent","now","closed","serverApi","helloOk","maxAwaitTimeMS","cmd","version","makeTopologyVersion","socketTimeoutMS","exhaustAllowed","RTTPinger","assign","exhaustCommand","ns","command","then","socket","makeSocket","makeConnection","performInitialHandshake","process","nextTick","done","type","ServerType","Unknown","setTimeout","tv","processId","counter","Long","isLong","fromNumber","measureRoundTripTime","clearTimeout","measureAndReschedule","conn","commandName","fn","isExpeditedCallToFnScheduled","stopped","isExecutionInProgress","hasExecutedOnce","_executeAndReschedule","timerId","lastExecutionEnded","_reschedule","currentTime","timeSinceLastCall","toString","JSON","stringify","toJSON","lastCallTime","isExpeditedCheckScheduled","ms"],"sources":["C:\\Users\\sumit\\Desktop\\Final project\\Expense-Tracker-Springboot-Frontend\\node_modules\\mongodb\\src\\sdam\\monitor.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\r\n\r\nimport { type Document, Long } from '../bson';\r\nimport { connect, makeConnection, makeSocket, performInitialHandshake } from '../cmap/connect';\r\nimport type { Connection, ConnectionOptions } from '../cmap/connection';\r\nimport { getFAASEnv } from '../cmap/handshake/client_metadata';\r\nimport { LEGACY_HELLO_COMMAND } from '../constants';\r\nimport { MongoError, MongoErrorLabel, MongoNetworkTimeoutError } from '../error';\r\nimport { MongoLoggableComponent } from '../mongo_logger';\r\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\r\nimport type { Callback, EventEmitterWithState } from '../utils';\r\nimport { calculateDurationInMs, makeStateMachine, now, ns } from '../utils';\r\nimport { ServerType, STATE_CLOSED, STATE_CLOSING } from './common';\r\nimport {\r\n  ServerHeartbeatFailedEvent,\r\n  ServerHeartbeatStartedEvent,\r\n  ServerHeartbeatSucceededEvent\r\n} from './events';\r\nimport { Server } from './server';\r\nimport type { TopologyVersion } from './server_description';\r\n\r\n/** @internal */\r\nconst kServer = Symbol('server');\r\n/** @internal */\r\nconst kMonitorId = Symbol('monitorId');\r\n/** @internal */\r\nconst kCancellationToken = Symbol('cancellationToken');\r\n/** @internal */\r\nconst kRoundTripTime = Symbol('roundTripTime');\r\n\r\nconst STATE_IDLE = 'idle';\r\nconst STATE_MONITORING = 'monitoring';\r\nconst stateTransition = makeStateMachine({\r\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\r\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\r\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\r\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\r\n});\r\n\r\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\r\nfunction isInCloseState(monitor: Monitor) {\r\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\r\n}\r\n\r\n/** @public */\r\nexport const ServerMonitoringMode = Object.freeze({\r\n  auto: 'auto',\r\n  poll: 'poll',\r\n  stream: 'stream'\r\n} as const);\r\n\r\n/** @public */\r\nexport type ServerMonitoringMode = (typeof ServerMonitoringMode)[keyof typeof ServerMonitoringMode];\r\n\r\n/** @internal */\r\nexport interface MonitorPrivate {\r\n  state: string;\r\n}\r\n\r\n/** @public */\r\nexport interface MonitorOptions\r\n  extends Omit<ConnectionOptions, 'id' | 'generation' | 'hostAddress'> {\r\n  connectTimeoutMS: number;\r\n  heartbeatFrequencyMS: number;\r\n  minHeartbeatFrequencyMS: number;\r\n  serverMonitoringMode: ServerMonitoringMode;\r\n}\r\n\r\n/** @public */\r\nexport type MonitorEvents = {\r\n  serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;\r\n  serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;\r\n  serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;\r\n  resetServer(error?: MongoError): void;\r\n  resetConnectionPool(): void;\r\n  close(): void;\r\n} & EventEmitterWithState;\r\n\r\n/** @internal */\r\nexport class Monitor extends TypedEventEmitter<MonitorEvents> {\r\n  /** @internal */\r\n  s: MonitorPrivate;\r\n  address: string;\r\n  options: Readonly<\r\n    Pick<\r\n      MonitorOptions,\r\n      | 'connectTimeoutMS'\r\n      | 'heartbeatFrequencyMS'\r\n      | 'minHeartbeatFrequencyMS'\r\n      | 'serverMonitoringMode'\r\n    >\r\n  >;\r\n  connectOptions: ConnectionOptions;\r\n  isRunningInFaasEnv: boolean;\r\n  [kServer]: Server;\r\n  connection: Connection | null;\r\n  [kCancellationToken]: CancellationToken;\r\n  /** @internal */\r\n  [kMonitorId]?: MonitorInterval;\r\n  rttPinger?: RTTPinger;\r\n  /** @internal */\r\n  override component = MongoLoggableComponent.TOPOLOGY;\r\n\r\n  constructor(server: Server, options: MonitorOptions) {\r\n    super();\r\n\r\n    this[kServer] = server;\r\n    this.connection = null;\r\n    this[kCancellationToken] = new CancellationToken();\r\n    this[kCancellationToken].setMaxListeners(Infinity);\r\n    this[kMonitorId] = undefined;\r\n    this.s = {\r\n      state: STATE_CLOSED\r\n    };\r\n    this.address = server.description.address;\r\n    this.options = Object.freeze({\r\n      connectTimeoutMS: options.connectTimeoutMS ?? 10000,\r\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,\r\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,\r\n      serverMonitoringMode: options.serverMonitoringMode\r\n    });\r\n    this.isRunningInFaasEnv = getFAASEnv() != null;\r\n    this.mongoLogger = this[kServer].topology.client?.mongoLogger;\r\n\r\n    const cancellationToken = this[kCancellationToken];\r\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\r\n    const connectOptions = {\r\n      id: '<monitor>' as const,\r\n      generation: server.pool.generation,\r\n      cancellationToken,\r\n      hostAddress: server.description.hostAddress,\r\n      ...options,\r\n      // force BSON serialization options\r\n      raw: false,\r\n      useBigInt64: false,\r\n      promoteLongs: true,\r\n      promoteValues: true,\r\n      promoteBuffers: true\r\n    };\r\n\r\n    // ensure no authentication is used for monitoring\r\n    delete connectOptions.credentials;\r\n    if (connectOptions.autoEncrypter) {\r\n      delete connectOptions.autoEncrypter;\r\n    }\r\n\r\n    this.connectOptions = Object.freeze(connectOptions);\r\n  }\r\n\r\n  connect(): void {\r\n    if (this.s.state !== STATE_CLOSED) {\r\n      return;\r\n    }\r\n\r\n    // start\r\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\r\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\r\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\r\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\r\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\r\n      immediate: true\r\n    });\r\n  }\r\n\r\n  requestCheck(): void {\r\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\r\n      return;\r\n    }\r\n\r\n    this[kMonitorId]?.wake();\r\n  }\r\n\r\n  reset(): void {\r\n    const topologyVersion = this[kServer].description.topologyVersion;\r\n    if (isInCloseState(this) || topologyVersion == null) {\r\n      return;\r\n    }\r\n\r\n    stateTransition(this, STATE_CLOSING);\r\n    resetMonitorState(this);\r\n\r\n    // restart monitor\r\n    stateTransition(this, STATE_IDLE);\r\n\r\n    // restart monitoring\r\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\r\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\r\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\r\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\r\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\r\n    });\r\n  }\r\n\r\n  close(): void {\r\n    if (isInCloseState(this)) {\r\n      return;\r\n    }\r\n\r\n    stateTransition(this, STATE_CLOSING);\r\n    resetMonitorState(this);\r\n\r\n    // close monitor\r\n    this.emit('close');\r\n    stateTransition(this, STATE_CLOSED);\r\n  }\r\n}\r\n\r\nfunction resetMonitorState(monitor: Monitor) {\r\n  monitor[kMonitorId]?.stop();\r\n  monitor[kMonitorId] = undefined;\r\n\r\n  monitor.rttPinger?.close();\r\n  monitor.rttPinger = undefined;\r\n\r\n  monitor[kCancellationToken].emit('cancel');\r\n\r\n  monitor.connection?.destroy({ force: true });\r\n  monitor.connection = null;\r\n}\r\n\r\nfunction useStreamingProtocol(monitor: Monitor, topologyVersion: TopologyVersion | null): boolean {\r\n  // If we have no topology version we always poll no matter\r\n  // what the user provided, since the server does not support\r\n  // the streaming protocol.\r\n  if (topologyVersion == null) return false;\r\n\r\n  const serverMonitoringMode = monitor.options.serverMonitoringMode;\r\n  if (serverMonitoringMode === ServerMonitoringMode.poll) return false;\r\n  if (serverMonitoringMode === ServerMonitoringMode.stream) return true;\r\n\r\n  // If we are in auto mode, we need to figure out if we're in a FaaS\r\n  // environment or not and choose the appropriate mode.\r\n  if (monitor.isRunningInFaasEnv) return false;\r\n  return true;\r\n}\r\n\r\nfunction checkServer(monitor: Monitor, callback: Callback<Document | null>) {\r\n  let start: number;\r\n  let awaited: boolean;\r\n  const topologyVersion = monitor[kServer].description.topologyVersion;\r\n  const isAwaitable = useStreamingProtocol(monitor, topologyVersion);\r\n  monitor.emitAndLogHeartbeat(\r\n    Server.SERVER_HEARTBEAT_STARTED,\r\n    monitor[kServer].topology.s.id,\r\n    undefined,\r\n    new ServerHeartbeatStartedEvent(monitor.address, isAwaitable)\r\n  );\r\n\r\n  function onHeartbeatFailed(err: Error) {\r\n    monitor.connection?.destroy({ force: true });\r\n    monitor.connection = null;\r\n\r\n    monitor.emitAndLogHeartbeat(\r\n      Server.SERVER_HEARTBEAT_FAILED,\r\n      monitor[kServer].topology.s.id,\r\n      undefined,\r\n      new ServerHeartbeatFailedEvent(monitor.address, calculateDurationInMs(start), err, awaited)\r\n    );\r\n\r\n    const error = !(err instanceof MongoError)\r\n      ? new MongoError(MongoError.buildErrorMessage(err), { cause: err })\r\n      : err;\r\n    error.addErrorLabel(MongoErrorLabel.ResetPool);\r\n    if (error instanceof MongoNetworkTimeoutError) {\r\n      error.addErrorLabel(MongoErrorLabel.InterruptInUseConnections);\r\n    }\r\n\r\n    monitor.emit('resetServer', error);\r\n    callback(err);\r\n  }\r\n\r\n  function onHeartbeatSucceeded(hello: Document) {\r\n    if (!('isWritablePrimary' in hello)) {\r\n      // Provide hello-style response document.\r\n      hello.isWritablePrimary = hello[LEGACY_HELLO_COMMAND];\r\n    }\r\n\r\n    const duration =\r\n      isAwaitable && monitor.rttPinger\r\n        ? monitor.rttPinger.roundTripTime\r\n        : calculateDurationInMs(start);\r\n\r\n    monitor.emitAndLogHeartbeat(\r\n      Server.SERVER_HEARTBEAT_SUCCEEDED,\r\n      monitor[kServer].topology.s.id,\r\n      hello.connectionId,\r\n      new ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable)\r\n    );\r\n\r\n    if (isAwaitable) {\r\n      // If we are using the streaming protocol then we immediately issue another 'started'\r\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\r\n      monitor.emitAndLogHeartbeat(\r\n        Server.SERVER_HEARTBEAT_STARTED,\r\n        monitor[kServer].topology.s.id,\r\n        undefined,\r\n        new ServerHeartbeatStartedEvent(monitor.address, true)\r\n      );\r\n      // We have not actually sent an outgoing handshake, but when we get the next response we\r\n      // want the duration to reflect the time since we last heard from the server\r\n      start = now();\r\n    } else {\r\n      monitor.rttPinger?.close();\r\n      monitor.rttPinger = undefined;\r\n\r\n      callback(undefined, hello);\r\n    }\r\n  }\r\n\r\n  const { connection } = monitor;\r\n  if (connection && !connection.closed) {\r\n    const { serverApi, helloOk } = connection;\r\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\r\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\r\n\r\n    const cmd = {\r\n      [serverApi?.version || helloOk ? 'hello' : LEGACY_HELLO_COMMAND]: 1,\r\n      ...(isAwaitable && topologyVersion\r\n        ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\r\n        : {})\r\n    };\r\n\r\n    const options = isAwaitable\r\n      ? {\r\n          socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\r\n          exhaustAllowed: true\r\n        }\r\n      : { socketTimeoutMS: connectTimeoutMS };\r\n\r\n    if (isAwaitable && monitor.rttPinger == null) {\r\n      monitor.rttPinger = new RTTPinger(\r\n        monitor[kCancellationToken],\r\n        Object.assign(\r\n          { heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS },\r\n          monitor.connectOptions\r\n        )\r\n      );\r\n    }\r\n\r\n    // Record new start time before sending handshake\r\n    start = now();\r\n\r\n    if (isAwaitable) {\r\n      awaited = true;\r\n      return connection.exhaustCommand(ns('admin.$cmd'), cmd, options, (error, hello) => {\r\n        if (error) return onHeartbeatFailed(error);\r\n        return onHeartbeatSucceeded(hello);\r\n      });\r\n    }\r\n\r\n    awaited = false;\r\n    connection\r\n      .command(ns('admin.$cmd'), cmd, options)\r\n      .then(onHeartbeatSucceeded, onHeartbeatFailed);\r\n\r\n    return;\r\n  }\r\n\r\n  // connecting does an implicit `hello`\r\n  (async () => {\r\n    const socket = await makeSocket(monitor.connectOptions);\r\n    const connection = makeConnection(monitor.connectOptions, socket);\r\n    // The start time is after socket creation but before the handshake\r\n    start = now();\r\n    try {\r\n      await performInitialHandshake(connection, monitor.connectOptions);\r\n      return connection;\r\n    } catch (error) {\r\n      connection.destroy({ force: false });\r\n      throw error;\r\n    }\r\n  })().then(\r\n    connection => {\r\n      if (isInCloseState(monitor)) {\r\n        connection.destroy({ force: true });\r\n        return;\r\n      }\r\n\r\n      monitor.connection = connection;\r\n      monitor.emitAndLogHeartbeat(\r\n        Server.SERVER_HEARTBEAT_SUCCEEDED,\r\n        monitor[kServer].topology.s.id,\r\n        connection.hello?.connectionId,\r\n        new ServerHeartbeatSucceededEvent(\r\n          monitor.address,\r\n          calculateDurationInMs(start),\r\n          connection.hello,\r\n          useStreamingProtocol(monitor, connection.hello?.topologyVersion)\r\n        )\r\n      );\r\n\r\n      callback(undefined, connection.hello);\r\n    },\r\n    error => {\r\n      monitor.connection = null;\r\n      awaited = false;\r\n      onHeartbeatFailed(error);\r\n    }\r\n  );\r\n}\r\n\r\nfunction monitorServer(monitor: Monitor) {\r\n  return (callback: Callback) => {\r\n    if (monitor.s.state === STATE_MONITORING) {\r\n      process.nextTick(callback);\r\n      return;\r\n    }\r\n    stateTransition(monitor, STATE_MONITORING);\r\n    function done() {\r\n      if (!isInCloseState(monitor)) {\r\n        stateTransition(monitor, STATE_IDLE);\r\n      }\r\n\r\n      callback();\r\n    }\r\n\r\n    checkServer(monitor, (err, hello) => {\r\n      if (err) {\r\n        // otherwise an error occurred on initial discovery, also bail\r\n        if (monitor[kServer].description.type === ServerType.Unknown) {\r\n          return done();\r\n        }\r\n      }\r\n\r\n      // if the check indicates streaming is supported, immediately reschedule monitoring\r\n      if (useStreamingProtocol(monitor, hello?.topologyVersion)) {\r\n        setTimeout(() => {\r\n          if (!isInCloseState(monitor)) {\r\n            monitor[kMonitorId]?.wake();\r\n          }\r\n        }, 0);\r\n      }\r\n\r\n      done();\r\n    });\r\n  };\r\n}\r\n\r\nfunction makeTopologyVersion(tv: TopologyVersion) {\r\n  return {\r\n    processId: tv.processId,\r\n    // tests mock counter as just number, but in a real situation counter should always be a Long\r\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\r\n    counter: Long.isLong(tv.counter) ? tv.counter : Long.fromNumber(tv.counter)\r\n  };\r\n}\r\n\r\n/** @internal */\r\nexport interface RTTPingerOptions extends ConnectionOptions {\r\n  heartbeatFrequencyMS: number;\r\n}\r\n\r\n/** @internal */\r\nexport class RTTPinger {\r\n  connection?: Connection;\r\n  /** @internal */\r\n  [kCancellationToken]: CancellationToken;\r\n  /** @internal */\r\n  [kRoundTripTime]: number;\r\n  /** @internal */\r\n  [kMonitorId]: NodeJS.Timeout;\r\n  closed: boolean;\r\n\r\n  constructor(cancellationToken: CancellationToken, options: RTTPingerOptions) {\r\n    this.connection = undefined;\r\n    this[kCancellationToken] = cancellationToken;\r\n    this[kRoundTripTime] = 0;\r\n    this.closed = false;\r\n\r\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\r\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\r\n  }\r\n\r\n  get roundTripTime(): number {\r\n    return this[kRoundTripTime];\r\n  }\r\n\r\n  close(): void {\r\n    this.closed = true;\r\n    clearTimeout(this[kMonitorId]);\r\n\r\n    this.connection?.destroy({ force: true });\r\n    this.connection = undefined;\r\n  }\r\n}\r\n\r\nfunction measureRoundTripTime(rttPinger: RTTPinger, options: RTTPingerOptions) {\r\n  const start = now();\r\n  options.cancellationToken = rttPinger[kCancellationToken];\r\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\r\n\r\n  if (rttPinger.closed) {\r\n    return;\r\n  }\r\n\r\n  function measureAndReschedule(conn?: Connection) {\r\n    if (rttPinger.closed) {\r\n      conn?.destroy({ force: true });\r\n      return;\r\n    }\r\n\r\n    if (rttPinger.connection == null) {\r\n      rttPinger.connection = conn;\r\n    }\r\n\r\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\r\n    rttPinger[kMonitorId] = setTimeout(\r\n      () => measureRoundTripTime(rttPinger, options),\r\n      heartbeatFrequencyMS\r\n    );\r\n  }\r\n\r\n  const connection = rttPinger.connection;\r\n  if (connection == null) {\r\n    connect(options).then(\r\n      connection => {\r\n        measureAndReschedule(connection);\r\n      },\r\n      () => {\r\n        rttPinger.connection = undefined;\r\n        rttPinger[kRoundTripTime] = 0;\r\n      }\r\n    );\r\n    return;\r\n  }\r\n\r\n  const commandName =\r\n    connection.serverApi?.version || connection.helloOk ? 'hello' : LEGACY_HELLO_COMMAND;\r\n  connection.command(ns('admin.$cmd'), { [commandName]: 1 }, undefined).then(\r\n    () => measureAndReschedule(),\r\n    () => {\r\n      rttPinger.connection?.destroy({ force: true });\r\n      rttPinger.connection = undefined;\r\n      rttPinger[kRoundTripTime] = 0;\r\n      return;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface MonitorIntervalOptions {\r\n  /** The interval to execute a method on */\r\n  heartbeatFrequencyMS: number;\r\n  /** A minimum interval that must elapse before the method is called */\r\n  minHeartbeatFrequencyMS: number;\r\n  /** Whether the method should be called immediately when the interval is started  */\r\n  immediate: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MonitorInterval {\r\n  fn: (callback: Callback) => void;\r\n  timerId: NodeJS.Timeout | undefined;\r\n  lastExecutionEnded: number;\r\n  isExpeditedCallToFnScheduled = false;\r\n  stopped = false;\r\n  isExecutionInProgress = false;\r\n  hasExecutedOnce = false;\r\n\r\n  heartbeatFrequencyMS: number;\r\n  minHeartbeatFrequencyMS: number;\r\n\r\n  constructor(fn: (callback: Callback) => void, options: Partial<MonitorIntervalOptions> = {}) {\r\n    this.fn = fn;\r\n    this.lastExecutionEnded = -Infinity;\r\n\r\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;\r\n    this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;\r\n\r\n    if (options.immediate) {\r\n      this._executeAndReschedule();\r\n    } else {\r\n      this._reschedule(undefined);\r\n    }\r\n  }\r\n\r\n  wake() {\r\n    const currentTime = now();\r\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\r\n\r\n    // TODO(NODE-4674): Add error handling and logging to the monitor\r\n    if (timeSinceLastCall < 0) {\r\n      return this._executeAndReschedule();\r\n    }\r\n\r\n    if (this.isExecutionInProgress) {\r\n      return;\r\n    }\r\n\r\n    // debounce multiple calls to wake within the `minInterval`\r\n    if (this.isExpeditedCallToFnScheduled) {\r\n      return;\r\n    }\r\n\r\n    // reschedule a call as soon as possible, ensuring the call never happens\r\n    // faster than the `minInterval`\r\n    if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {\r\n      this.isExpeditedCallToFnScheduled = true;\r\n      this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);\r\n      return;\r\n    }\r\n\r\n    this._executeAndReschedule();\r\n  }\r\n\r\n  stop() {\r\n    this.stopped = true;\r\n    if (this.timerId) {\r\n      clearTimeout(this.timerId);\r\n      this.timerId = undefined;\r\n    }\r\n\r\n    this.lastExecutionEnded = -Infinity;\r\n    this.isExpeditedCallToFnScheduled = false;\r\n  }\r\n\r\n  toString() {\r\n    return JSON.stringify(this);\r\n  }\r\n\r\n  toJSON() {\r\n    const currentTime = now();\r\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\r\n    return {\r\n      timerId: this.timerId != null ? 'set' : 'cleared',\r\n      lastCallTime: this.lastExecutionEnded,\r\n      isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,\r\n      stopped: this.stopped,\r\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\r\n      minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,\r\n      currentTime,\r\n      timeSinceLastCall\r\n    };\r\n  }\r\n\r\n  private _reschedule(ms?: number) {\r\n    if (this.stopped) return;\r\n    if (this.timerId) {\r\n      clearTimeout(this.timerId);\r\n    }\r\n\r\n    this.timerId = setTimeout(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\r\n  }\r\n\r\n  private _executeAndReschedule = () => {\r\n    if (this.stopped) return;\r\n    if (this.timerId) {\r\n      clearTimeout(this.timerId);\r\n    }\r\n\r\n    this.isExpeditedCallToFnScheduled = false;\r\n    this.isExecutionInProgress = true;\r\n\r\n    this.fn(() => {\r\n      this.lastExecutionEnded = now();\r\n      this.isExecutionInProgress = false;\r\n      this._reschedule(this.heartbeatFrequencyMS);\r\n    });\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}